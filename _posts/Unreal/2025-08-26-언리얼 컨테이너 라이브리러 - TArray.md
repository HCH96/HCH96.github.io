---
title: 언리얼 컨테이너 라이브러리Ⅰ- TArray
date: 2025-08-26 18:40:00 +09:00
categories: [Unreal, 언리얼 c++의 이해]
published: true
tags:
  [unreal, cpp, tarray]
---

## TArray
`TArray`는 언리얼 컨테이너 라이브러리 중 하나로, 같은 타입의 객체를 순서대로 저장하는 가변 배열 자료구조이다. 대체로 C++ STL의 `vector`와 유사하다.

- 특징
    - 데이터를 연속된 메모리에 저장 → 메모리 효율 & 캐시 효율 ↑
    - 빠른 임의 접근 ([] 연산자) 가능
    - 요소 순회 속도가 빠름

- 단점
    - 배열 중간/앞 부분 삽입·삭제 시 비용이 큼
    - 데이터가 많을 때 검색/삭제/수정 성능이 떨어짐
    → 검색이 잦으면 TSet 사용하는 것이 좋음

- 값 타입(Value Type)
    - int32, float 같은 내장형처럼 취급
    - 확장 목적 아니므로 TArray를 상속받아 새로운 자료구조를 구현하는 것은 좋지 않음
    - new/delete로 생성/소멸 X-> 스택/멤버 변수로 사용 O -> 내부적으로 메모리가 자동으로 관리되기 때문에 동적 할당을 할 이유가 없을 뿐더러, 수명 관리가 복잡해지고 메모리 누수 위험이 커짐
    - 요소(Element)는 배열이 소유, TArray 소멸 시 요소들도 자동으로 소멸

- 복사 동작
    - 한 TArray를 다른 TArray 변수에 대입하면 요소가 복사되고, 공유 상태(포인터 공유 등)는 없음

### TArray 사용법

#### 선언 및 초기화
```cpp
    TArray<int32> IntArray;

    IntArray.Init(10, 5);
	// IntArray == [10,10,10,10,10]
```

- TArray의 엘레먼트 유형은 int32, FString, TSharedPtr 등과 같이 보통의 C++ 값 규칙에 따라 복사 및 소멸 가능한 값 유형은 어떤 것이든 사용할 수 있다.

#### 인스턴스 추가
```cpp
	TArray<FString> StrArr;
	StrArr.Add    (TEXT("Hello"));
	StrArr.Emplace(TEXT("World"));
	// StrArr == ["Hello","World"]

    FString Arr[] = { TEXT("of"), TEXT("Tomorrow") };
	StrArr.Append(Arr, ARRAY_COUNT(Arr));
	// StrArr == ["Hello","World","of","Tomorrow"]
 
```

- 배열에 새 인스턴스를 추가할 때는 `Add`, `Emplace`, `Append를` 사용할 수 있다.
- `Add` : 인스턴스를 복사 또는 이동하여 배열에 추가한다.
- `Emplace` : 지정한 인수를 사용해 배열 내부에서 바로 인스턴스를 생성한다.
    - 예시에서 Add는 먼저 FString 임시 객체를 만든 뒤 복사하지만, Emplace는 임시 객체 없이 인자를 이용해 바로 생성한다.
    - 따라서 복잡한 값 유형의 경우 Add보다 Emplace가 복사 비용을 줄일 수 있어 성능상 유리하다.
- `Append` : 다른 TArray나 C 배열을 받아 다수의 인스턴스를 한 번에 추가한다.

```cpp
	StrArr.AddUnique(TEXT("!"));
	// StrArr == ["Hello","World","of","Tomorrow","!"]
 
	StrArr.AddUnique(TEXT("!"));
	// StrArr is unchanged as "!" is already an element
```

- `AddUnique` : 배열에 동일한 인스턴스가 없을 경우에만 새 요소를 추가한다.
- 존재 여부는 엘리먼트 타입의 `operator==`를 통해 검사한다.

```cpp
	StrArr.Insert(TEXT("Brave"), 1);
	// StrArr == ["Hello","Brave","World","of","Tomorrow","!"]
```

- `Insert` : 지정한 인덱스 위치에 단일 요소나 배열을 삽입한다.
- 배열 중간에도 삽입할 수 있지만, 기존 데이터를 뒤로 밀어야 하므로 퍼포먼스가 좋지 않다.

```cpp
    StrArr.SetNum(8);
	// StrArr == ["Hello","Brave","World","of","Tomorrow","!","",""]

    StrArr.SetNum(6);
	// StrArr == ["Hello","Brave","World","of","Tomorrow","!"]
 
```
- SetNum : 배열 크기를 직접 설정한다.
    - 크기가 늘어나면 엘리먼트 타입의 기본 생성자를 호출해 새 요소를 추가한다.
    - 크기가 줄어들면 뒤쪽 요소를 제거한다.

#### 반복
TArray의 요소를 순회하는 방법은 여러 가지가 있다.

1. 범위 기반 for문
```cpp
    FString JoinedStr;
	for (auto& Str : StrArr)
	{
		JoinedStr += Str;
		JoinedStr += TEXT(" ");
	}
	// JoinedStr == "Hello Brave World of Tomorrow ! "
```
- 가장 간결하고 가독성이 좋다.
- C++11 이후 표준 문법으로 많이 사용된다.

---
2. 인덱스 기반 for문
```cpp
    for (int32 Index = 0; Index != StrArr.Num(); ++Index)
	{
		JoinedStr += StrArr[Index];
		JoinedStr += TEXT(" ");
	}
```
- 인덱스를 직접 제어할 수 있다.
- 특정 범위만 순회하거나, 인덱스를 활용한 접근이 필요할 때 적합하다.

---
3. 이터레이터 기반 for문
```cpp
    for (auto It = StrArr.CreateConstIterator(); It; ++It)
	{
		JoinedStr += *It;
		JoinedStr += TEXT(" ");
	}
```
- `CreateIterator()` : 읽기-쓰기 가능한 이터레이터 생성
- `CreateConstIterator()` : 읽기 전용 이터레이터 생성

---

#### 소팅
TArray는 Sort 함수를 호출해 간단히 정렬할 수 있다.

```cpp
    StrArr.Sort();
    // StrArr == ["!","Brave","Hello","of","Tomorrow","World"]
```

- 기본적으로 엘리먼트 타입의 operator< 를 사용해 정렬한다.
- FString의 경우 대소문자 구분 없이 사전식 비교로 정렬된다.

---

특정 기준으로 정렬하려면 람다 함수를 인자로 전달할 수 있다.

```cpp
    StrArr.Sort([](const FString& A, const FString& B) {
        return A.Len() < B.Len();
    });
    // StrArr == ["!","of","Hello","Brave","World","Tomorrow"]
```
- 문자열 길이 기준으로 정렬된 결과.
- 단, Sort는 안정적(stable) 정렬이 아니기 때문에, "Hello", "Brave", "World"처럼 길이가 같은 문자열의 상대 순서는 보장되지 않는다.

---

```cpp
    StrArr.StableSort([](const FString& A, const FString& B) {
        return A.Len() < B.Len();
    });
    // StrArr == ["!","of","Brave","Hello","World","Tomorrow"]
```
- 안정 정렬(stable sort) 이므로, 동등한 요소의 기존 순서를 유지한다.
- 예시에서 "Brave", "Hello", "World"는 길이가 같지만, 기존 인스턴스의 순서가 그대로 보존된다.
- 내부적으로 병합 정렬(Merge Sort) 로 구현되어 있다.

---

#### 쿼리

```cpp
    int32 Count = StrArr.Num();
    // Count == 6
```
- `Num`은 배열에 몇 개의 요소가 들어있는지 확인한다.

---

```cpp
    FString* StrPtr = StrArr.GetData();
    // StrPtr[0] == "!"
    // StrPtr[5] == "Tomorrow"
    // StrPtr[6] → undefined behavior
```
`GetData`는 배열 메모리에 직접 접근할 수 있는 포인터를 반환한다.
- 포인터는 배열이 유효할 때만, 그리고 변형 연산 전까지만 유효하다.
- Num 크기까지만 안전하게 접근 가능하다.
- const 배열에서 호출하면 const 포인터가 반환된다.

---

```cpp
    uint32 ElementSize = StrArr.GetTypeSize();
    // ElementSize == sizeof(FString)
    ```
    - `GetTypeSize`는 엘리먼트의 크기를 반환한다.

---
```cpp
    FString Elem1 = StrArr[1];
    // Elem1 == "of"

    StrArr[3] = StrArr[3].ToUpper();
    // StrArr == ["!","of","Brave","HELLO","World","Tomorrow"]
```
- `operator[]`는 배열 요소에 인덱스로 접근한다.
- 잘못된 인덱스(0 미만, Num 이상) 사용 시 런타임 에러 발생.
- const 배열일 경우, const 참조를 반환한다.

---
```cpp
bool bValidM1 = StrArr.IsValidIndex(-1); // false
bool bValid0  = StrArr.IsValidIndex(0);  // true
bool bValid5  = StrArr.IsValidIndex(5);  // true
bool bValid6  = StrArr.IsValidIndex(6);  // false
```
- `IsValidIndex` 특정 인덱스가 유효한지 확인한다.

---
```cpp
    FString ElemEnd  = StrArr.Last();    // "Tomorrow"
    FString ElemEnd0 = StrArr.Last(0);   // "Tomorrow"
    FString ElemEnd1 = StrArr.Last(1);   // "World"
    FString ElemTop  = StrArr.Top();     // "Tomorrow"
```
- `Last` / `Top`은 마지막 요소 또는 뒤에서부터 N번째 요소에 접근한다.

---
##### **포함 여부 검사**
```cpp
    bool bHello   = StrArr.Contains(TEXT("Hello"));   // true
    bool bGoodbye = StrArr.Contains(TEXT("Goodbye")); // false

    bool bLen5 = StrArr.ContainsByPredicate([](const FString& Str){
        return Str.Len() == 5;
    }); // true

    bool bLen6 = StrArr.ContainsByPredicate([](const FString& Str){
        return Str.Len() == 6;
    }); // false
```
- `Contains`은 특정 값이 들어있는지 확인한다.
- `ContainsByPredicate`는 특정 조건을 만족하는 요소가 있는지 검사한다.

---
##### **검색**

```cpp
    int32 Index;
    if (StrArr.Find(TEXT("Hello"), Index)) {
        // Index == 3
    }

    int32 Index2     = StrArr.Find(TEXT("Hello"));   // 3
    int32 IndexLast2 = StrArr.FindLast(TEXT("Hello"));// 3
    int32 IndexNone  = StrArr.Find(TEXT("None"));    // INDEX_NONE

```
- `Find` / `FindLast` : 요소를 찾아 인덱스를 반환한다.
    - 못 찾으면 `INDEX_NONE` 반환.
    - 인덱스를 아웃 파라미터로 받을 수도 있고, 함수 반환값으로 바로 받을 수도 있다.

---

```cpp
    int32 Index = StrArr.IndexOfByKey(TEXT("Hello"));
    // Index == 3
```

- `IndexOfByKey` : 임의 키와 비교해서 요소 인덱스를 찾는다.
    - operator==(ElementType, KeyType) 가 정의되어 있어야 한다.
    
---

```cpp
    int32 Index = StrArr.IndexOfByPredicate([](const FString& Str){
        return Str.Contains(TEXT("r"));
    });
    // Index == 2
```
- `IndexOfByPredicate` : 조건을 만족하는 첫 번째 요소 인덱스를 찾는다.
    - 못 찾으면 `INDEX_NONE` 반환.

---

```cpp
    auto* OfPtr  = StrArr.FindByKey(TEXT("of"));   // &StrArr[1]
    auto* ThePtr = StrArr.FindByKey(TEXT("the"));  // nullptr
```
- `FindByKey` : 키로 요소를 찾고, 해당 요소의 포인터를 반환한다. 없으면 nullptr 반환.

---

```cpp
    auto* Len5Ptr = StrArr.FindByPredicate([](const FString& Str){
        return Str.Len() == 5;
    }); // &StrArr[2]

    auto* Len6Ptr = StrArr.FindByPredicate([](const FString& Str){
        return Str.Len() == 6;
    }); // nullptr
```
- `FindByPredicate` : 조건을 만족하는 요소의 포인터를 반환한다. 없으면 nullptr 반환.

---
```cpp
    auto Filter = StrArr.FilterByPredicate([](const FString& Str){
        return !Str.IsEmpty() && Str[0] < TEXT('M');
    });
```
- `FilterByPredicate` : 조건에 맞는 모든 요소를 새 배열로 반환한다.

#### **제거**

```cpp
    TArray<int32> ValArr;
    int32 Temp[] = { 10, 20, 30, 5, 10, 15, 20, 25, 30 };
    ValArr.Append(Temp, ARRAY_COUNT(Temp));
    // ValArr == [10,20,30,5,10,15,20,25,30]

    ValArr.Remove(20);
    // ValArr == [10,30,5,10,15,25,30]
```
`Remove` : `operator==`를 기준으로 주어진 값과 동일한 모든 요소를 제거한다.

---

```cpp
    ValArr.RemoveSingle(30);
    // ValArr == [10,5,10,15,25,30]
```
- `RemoveSingle`
    - 첫 번째로 일치한 요소 하나만 제거한다.
    - 중복된 요소가 있어도 맨 앞의 하나만 제거된다.
    - 배열에 해당 요소가 하나만 있는 것이 확실하다면 효율적이다.

---

```cpp
    ValArr.RemoveAt(2);  // 인덱스 2 요소 제거
    // ValArr == [10,5,15,25,30]

    ValArr.RemoveAt(99); // 런타임 오류 (잘못된 인덱스)
```
- `RemoveAt` : 0 기반 인덱스를 지정해 요소를 제거한다.
    - 유효하지 않은 인덱스를 전달하면 런타임 오류가 발생한다.

---
```cpp
    ValArr.RemoveAll([](int32 Val) {
        return Val % 3 == 0;
    });
    // ValArr == [10,5,25]
```

- `RemoveAll` : 조건에 일치하는 모든 요소를 제거한다.

---

```cpp
    TArray<int32> ValArr2;
    for (int32 i = 0; i != 10; ++i)
        ValArr2.Add(i % 5);
    // ValArr2 == [0,1,2,3,4,0,1,2,3,4]

    ValArr2.RemoveSwap(2);
    // ValArr2 == [0,1,4,3,4,0,1,3]

    ValArr2.RemoveAtSwap(1);
    // ValArr2 == [0,3,4,3,4,0,1]

    ValArr2.RemoveAllSwap([](int32 Val) {
        return Val % 3 == 0;
    });
    // ValArr2 == [1,4,4]
```
- `RemoveSwap` / `RemoveAtSwap` / `RemoveAllSwap`
    - 요소 제거 시 순서를 유지하지 않고 뒤 요소와 Swap 처리한다.
    - 불필요한 이동을 줄여 성능이 더 효율적이다.
- 일반 Remove 계열은 순서를 보장하지만 비용이 크고, Swap 계열은 순서를 버리는 대신 성능이 좋다.

---
```cpp
    ValArr2.Empty();
    // ValArr2 == []
```
- `Empty` : 배열을 완전히 비운다.

#### **연산자**
TArray는 일반적인 값 타입처럼 복사, 대입, 비교 연산을 지원한다.

1. **복사 (Copy)**

TArray는 요소를 깊은 복사(Deep Copy)한다.
- 새 배열에는 원본 요소의 별도 사본이 생성된다.
- 따라서 한쪽을 수정해도 다른 배열에는 영향이 없다.
```cpp
    TArray<int32> ValArr3;
    ValArr3.Add(1);
    ValArr3.Add(2);
    ValArr3.Add(3);

    auto ValArr4 = ValArr3;
    // ValArr4 == [1,2,3]

    ValArr4[0] = 5;
    // ValArr3 == [1,2,3]
    // ValArr4 == [5,2,3]

```

---

2. **배열 연결 (operator+=)**
Append의 대안으로 += 연산자를 사용할 수 있다.

```cpp
ValArr4 += ValArr3;
// ValArr4 == [5,2,3,1,2,3]
```

---

3. **이동 (MoveTemp)**
TArray는 이동 의미론을 지원한다.
- MoveTemp 사용 시, 데이터 소유권이 이전되고 원본은 비워진다.
```cpp
    ValArr3 = MoveTemp(ValArr4);
    // ValArr3 == [5,2,3,1,2,3]
    // ValArr4 == []
```

4. **비교 (operator==, operator!=)**
배열 비교 시
- 요소의 개수와 순서가 모두 동일해야 같다고 본다.
- 각 요소 비교에는 해당 타입의 operator==가 사용된다.
```cpp
    TArray<FString> FlavorArr1;
    FlavorArr1.Emplace(TEXT("Chocolate"));
    FlavorArr1.Emplace(TEXT("Vanilla"));
    // FlavorArr1 == ["Chocolate","Vanilla"]

    auto FlavorArr2 = FlavorArr1;
    // FlavorArr2 == ["Chocolate","Vanilla"]

    bool bComparison1 = (FlavorArr1 == FlavorArr2);
    // true

    for (auto& Str : FlavorArr2)
    {
        Str = Str.ToUpper();
    }
    // FlavorArr2 == ["CHOCOLATE","VANILLA"]

    bool bComparison2 = (FlavorArr1 == FlavorArr2);
    // true (FString 비교는 대소문자를 무시)

    Exchange(FlavorArr2[0], FlavorArr2[1]);
    // FlavorArr2 == ["VANILLA","CHOCOLATE"]

    bool bComparison3 = (FlavorArr1 == FlavorArr2);
    // false (순서가 달라졌기 때문)
```

#### **슬랙(Slack)**
`TArray는` 크기를 자유롭게 변경할 수 있으므로, 메모리 사용량이 가변적이다. `슬랙(Slack)`은 현재 요소 개수(Num) 와 다음 재할당 전까지 수용 가능한 최대 개수(Max) 의 차이를 의미한다.

- 추가(Add) 시마다 매번 재할당이 일어나면 성능 비용이 크기 때문에, 얼로케이터는 요청보다 넉넉한 공간을 미리 할당한다.
- 삭제(Remove) 시에도 메모리가 곧바로 줄어들지는 않고, 남는 공간(슬랙, Slack)이 그대로 유지된다.

---

- `GetSlack`, `Num`, `Max`
    - Num : 현재 요소 개수
    - Max : 재할당 없이 담을 수 있는 최대 요소 개수
    - GetSlack : Max - Num

```cpp
    TArray<int32> SlackArray;
    // SlackArray.GetSlack() == 0
    // SlackArray.Num()      == 0
    // SlackArray.Max()      == 0

    SlackArray.Add(1);
    // GetSlack == 3, Num == 1, Max == 4

    SlackArray.Add(2);
    SlackArray.Add(3);
    SlackArray.Add(4);
    SlackArray.Add(5);
    // GetSlack == 17, Num == 5, Max == 22

```
---

- `Empty` : 모든 요소를 제거하고, 슬랙 크기를 옵션으로 지정할 수 있다.

```cpp
    SlackArray.Empty();
    // GetSlack == 0, Num == 0, Max == 0

    SlackArray.Empty(3);
    // GetSlack == 3, Num == 0, Max == 3

    SlackArray.Add(1);
    SlackArray.Add(2);
    SlackArray.Add(3);
    // GetSlack == 0, Num == 3, Max == 3
```

---

- `Reset` : Empty와 비슷하지만, 요청한 슬랙이 현재 할당보다 작으면 메모리를 해제하지 않고, 필요 시에만 새로 할당한다.

```cpp
    SlackArray.Reset(0);
    // GetSlack == 3, Num == 0, Max == 3

    SlackArray.Reset(10);
    // GetSlack == 10, Num == 0, Max == 10
```

---

- `Shrink` : 남아있는 모든 슬랙을 제거하고, 현재 요소 수에 꼭 맞는 크기로 재할당한다.
```cpp
    SlackArray.Add(5);
    SlackArray.Add(10);
    SlackArray.Add(15);
    SlackArray.Add(20);
    // GetSlack == 6, Num == 4, Max == 10

    SlackArray.Shrink();
    // GetSlack == 0, Num == 4, Max == 4
```

#### **원시 메모리(Raw Memory)**
`TArray는` 결국 할당된 메모리를 감싼 컨테이너일 뿐이다.
일반적으로는 안전하게 동작하지만, 성능 최적화나 특별한 상황에서는 생성자 호출을 생략하고 직접 메모리에 접근해야 할 때가 있다.

---

- `AddUninitialized` / `InsertUninitialized`
    - 요소 공간만 확보하고 생성자는 호출하지 않음.
    - 이후 Memcpy 같은 저수준 복사로 값을 덮어쓸 때 유용하다.

```cpp
int32 SrcInts[] = { 2, 3, 5, 7 };
TArray<int32> UninitInts;
UninitInts.AddUninitialized(4);
FMemory::Memcpy(UninitInts.GetData(), SrcInts, 4 * sizeof(int32));
// UninitInts == [2,3,5,7]
```

직접 객체를 생성자 호출로 초기화할 수도 있다.

```cpp
TArray<FString> UninitStrs;
UninitStrs.Emplace(TEXT("A"));
UninitStrs.Emplace(TEXT("D"));
UninitStrs.InsertUninitialized(1, 2);

new ((void*)(UninitStrs.GetData() + 1)) FString(TEXT("B"));
new ((void*)(UninitStrs.GetData() + 2)) FString(TEXT("C"));
// UninitStrs == ["A","B","C","D"]
```
