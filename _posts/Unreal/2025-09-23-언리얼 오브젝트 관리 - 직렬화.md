---
title: 언리얼 오브젝트 관리Ⅰ- 직렬화
date: 2025-09-23 18:40:00 +09:00
categories: [Unreal, 언리얼 c++의 이해]
published: true
tags:
  [unreal, cpp, serialization]
---

## 직렬화
직렬화는 오브젝트나 연결된 오브젝트 묶음을 바이트 스트림(Byte Stream)으로 변환하는 과정을 말한다.
이를 통해 프로그램의 현재 상태를 저장하거나 다른 환경에서 그대로 복원할 수 있다.

직렬화가 사용되는 대표적인 예시:
- **저장/로드 기능**: 게임 진행 상태를 파일로 저장 후 다시 불러오기  
- **복사/붙여넣기**: 객체 정보를 클립보드에 복사해 다른 프로그램에 전달  
- **네트워크 동기화**: 현재 프로그램의 상태를 네트워크로 전송해 다른 컴퓨터에서 복원  
- **데이터 관리**: 압축/암호화를 통해 데이터를 효율적이고 안전하게 보관  

---

## 직렬화 구현 시 고려해야 할 점

1. **데이터 레이아웃**  
   - 객체가 가진 다양한 데이터를 어떤 방식으로 변환할지 결정해야 한다.  
   - 예: 정수, 문자열, 포인터, 사용자 정의 타입 등  

2. **이식성(Portability)**  
   - 서로 다른 하드웨어나 운영체제에서도 직렬화된 데이터를 호환할 수 있어야 한다.  
   - 엔디안(Endian) 문제나 문자열 인코딩 문제 고려 필요.  

3. **버전 관리**  
   - 게임이 업데이트되면서 데이터 구조가 바뀔 수 있다.  
   - 이전 버전의 저장 데이터를 어떻게 읽어올 것인지 처리해야 한다.  

4. **성능**  
   - 네트워크 비용을 줄이고 빠르게 읽고 쓰기 위해 어떤 데이터 형식을 사용할지 고민해야 한다.  
   - 텍스트 기반(JSON 등) vs 이진(Binary) 기반 직렬화의 선택  

5. **보안**  
   - 저장된 데이터를 암호화하거나 체크섬을 추가해 변조를 막아야 한다.  

6. **에러 처리**  
   - 전송이나 저장 과정에서 데이터 손상 가능성을 고려하고, 에러 발생 시 복구 방안을 마련해야 한다.  

---

## 언리얼 엔진의 직렬화 시스템
언리얼 엔진은 위와 같은 복잡한 문제들을 이미 고려한 **직렬화 시스템(Serialization System)**을 제공한다.  

`FArchive` 클래스와 `연산자 오버로딩 (<<)`을 통해 다양한 데이터 타입을 손쉽게 직렬화/역직렬화할 수 있다.  

### 주요 아카이브 클래스
언리얼은 다양한 상황에 맞는 아카이브 클래스를 제공한다:

- **메모리 기반 아카이브**  
  - `FMemoryReader`, `FMemoryWriter`  
  - 메모리 버퍼에서 데이터를 읽고 쓰기  

- **파일 기반 아카이브**  
  - `FArchiveFileReaderGeneric`, `FArchiveFileWriterGeneric`  
  - 디스크 파일로 저장/불러오기  

- **언리얼 오브젝트 아카이브**  
  - `FArchiveUObject`  
  - `UObject`와 관련된 특수 직렬화 처리  

- **JSON 직렬화**  
  - 별도의 JSON 라이브러리 제공  
  - 사람이 읽기 쉽고 디버깅에 유리하지만 성능은 이진 직렬화보다 낮음  

---

## 언리얼 직렬화

### **일반 c++ 클래스 직렬화**

`FStudentData`라는 일반 C++ 구조체를 만들고, `friend operator<<`를 오버로딩하여 직렬화/역직렬화를 지원한다.  

```cpp
  // 일반 C++ 구조체
  struct FStudentData
  {
      FStudentData() {}
      FStudentData(int32 InOrder, const FString& InName) :Order(InOrder), Name(InName) {}

      // FArchive << 연산자 오버로딩
      // -> FArchive에 데이터 쓰기/읽기 지원
      friend FArchive& operator<<(FArchive& Ar, FStudentData& InStudentData)
      {
          Ar << InStudentData.Order;   // 순번 직렬화
          Ar << InStudentData.Name;    // 이름 직렬화
          return Ar;
      }

      int32 Order = -1;
      FString Name = TEXT("홍길동");
  };
```


```cpp
  // 저장할 데이터 준비
  FStudentData RawDataSrc(16, TEXT("학생"));

  // 저장할 경로 준비
  const FString RawDataFileName(TEXT("RawData.bin"));
  FString RawDataAbsolutePath = FPaths::Combine(*SavedDir, *RawDataFileName);

  // ----- 저장 -----
  if (FArchive* RawFileWriterAr = IFileManager::Get().CreateFileWriter(*RawDataAbsolutePath))
  {
      *RawFileWriterAr << RawDataSrc;   // 데이터 직렬화 -> 파일로 저장
      RawFileWriterAr->Close();
      delete RawFileWriterAr;
  }

  // ----- 복원 -----
  FStudentData RawDataDest;
  if (FArchive* RawFileReaderAr = IFileManager::Get().CreateFileReader(*RawDataAbsolutePath))
  {
      *RawFileReaderAr << RawDataDest;  // 파일 -> 구조체 복원
      RawFileReaderAr->Close();
      delete RawFileReaderAr;

      // 복원된 데이터 출력
      UE_LOG(LogTemp, Log, TEXT("[RawData] 이름 %s 순번 %d"), *RawDataDest.Name, RawDataDest.Order);
  }

```

### **언리얼 오브젝트 직렬화 (UObject + FArchive)**
UStudent라는 UObject 파생 클래스를 만들고 Serialize()를 오버라이드해서 직렬화 규칙을 정의한다.

```cpp
  UCLASS()
  class UNREALSERIALIZATION_API UStudent : public UObject
  {
      GENERATED_BODY()
  public:
      UStudent();

      int32 GetOrder() const { return Order; }
      void SetOrder(int32 InOrder) { Order = InOrder; }

      const FString& GetName() const { return Name; }
      void SetName(const FString& InName) { Name = InName; }

      // UObject 직렬화 함수 오버라이드
      virtual void Serialize(FArchive& Ar) override;

  private:
      UPROPERTY() int32 Order;
      UPROPERTY() FString Name;
  };

  // 직렬화 규칙 구현
  void UStudent::Serialize(FArchive& Ar)
  {
      Ar << Order;   // 순번 직렬화
      Ar << Name;    // 이름 직렬화
  }
```

```cpp
  // UObject 생성 및 데이터 세팅
  StudentSrc = NewObject<UStudent>();
  StudentSrc->SetOrder(30);
  StudentSrc->SetName(TEXT("학생"));

  // ----- 메모리에 직렬화 -----
  TArray<uint8> BufferArray;
  FMemoryWriter MemoryWriterAr(BufferArray);
  StudentSrc->Serialize(MemoryWriterAr);  // 객체 -> 바이트 배열

  // ----- 파일로 저장 -----
  if (TUniquePtr<FArchive> FileWriterAr = TUniquePtr<FArchive>(IFileManager::Get().CreateFileWriter(*ObjectDataAbsolutePath)))
  {
      *FileWriterAr << BufferArray;  // 바이트 배열을 파일에 기록
  }

  // ----- 파일에서 읽기 -----
  TArray<uint8> BufferArrayFromFile;
  if (TUniquePtr<FArchive> FileReaderAr = TUniquePtr<FArchive>(IFileManager::Get().CreateFileReader(*ObjectDataAbsolutePath)))
  {
      *FileReaderAr << BufferArrayFromFile;  // 파일 -> 바이트 배열
  }

  // ----- 메모리에서 역직렬화 -----
  FMemoryReader MemoryReaderAr(BufferArrayFromFile);
  UStudent* StudentDest = NewObject<UStudent>();
  StudentDest->Serialize(MemoryReaderAr);  // 바이트 배열 -> 객체 복원

  // 결과 출력
  PrintStudentInfo(StudentDest, TEXT("ObjectData"));
```

### ***JSON 직렬화 (FJsonObjectConverter)**
FJsonObjectConverter를 사용하면 UObject를 사람이 읽기 쉬운 JSON 형식으로 직렬화할 수 있다.
저장 파일은 .txt로 만들고, 다시 불러와 역직렬화한다.

```cpp
  // Json 파일 경로 지정
  const FString JsonDataFileName(TEXT("StudentJsonData.txt"));
  FString JsonDataAbsolutePath = FPaths::Combine(*SavedDir, *JsonDataFileName);

  // ----- UStudent -> JsonObject -----
  TSharedRef<FJsonObject> JsonObjectSrc = MakeShared<FJsonObject>();
  FJsonObjectConverter::UStructToJsonObject(StudentSrc->GetClass(), StudentSrc, JsonObjectSrc);

  // JsonObject -> String 변환
  FString JsonOutString;
  TSharedRef<TJsonWriter<TCHAR>> JsonWriterAr = TJsonWriterFactory<TCHAR>::Create(&JsonOutString);
  if (FJsonSerializer::Serialize(JsonObjectSrc, *JsonWriterAr))
  {
      // String을 파일에 저장
      FFileHelper::SaveStringToFile(JsonOutString, *JsonDataAbsolutePath);
  }

  // ----- 파일 -> String -----
  FString JsonInString;
  FFileHelper::LoadFileToString(JsonInString, *JsonDataAbsolutePath);

  // ----- String -> JsonObject -----
  TSharedRef<TJsonReader<TCHAR>> JsonReaderAr = TJsonReaderFactory<TCHAR>::Create(JsonInString);
  TSharedPtr<FJsonObject> JsonObjectDest;

  // ----- JsonObject -> UStudent -----
  if (FJsonSerializer::Deserialize(JsonReaderAr, JsonObjectDest))
  {
      UStudent* JsonStudentDest = NewObject<UStudent>();
      if (FJsonObjectConverter::JsonObjectToUStruct(JsonObjectDest.ToSharedRef(), JsonStudentDest->GetClass(), JsonStudentDest))
      {
          // 최종 결과 출력
          PrintStudentInfo(JsonStudentDest, TEXT("JsonData"));
      }
  }
```

## 메모리, JSON 객체를 거쳐서 파일에 쓰는 이유

### UObject 직렬화
`UObject::Serialize`로 직렬화할 땐 보통 `TArray<uint8>` 버퍼 -> 파일 방식을 쓴다.

- 경계 정보 자동 관리
  만약 여러개의 오브젝트를 한 파일에 저장할 경우, 경계에 대한 정보를 따로 저장해줘야 하는데, 메모리 버퍼를 사용할 경우 길이 + 데이터가 함께 기록되어, 복원할 때 경계가 명확하다.

- 후처리 삽입
  압축, 암호화, 체크섬 등은 버퍼 단위로 처리하는 게 편하다.

- 다중 용도 재사용
  만든 버퍼를 파일에도 쓰고, 네트워크 패킷으로도 보낼 수 있다.

- 원자성 있는 저장
  완성된 버퍼를 한 번에 쓰면, 중간에 깨질 위험이 줄어든다.

>> 꼭 버퍼를 거쳐야 하는 건 아니다. 파일 아카이브에 바로 Student->Serialize(*Ar) 해도 된다. 하지만 이 경우 사이즈/프레이밍을 직접 기록해 관리해야 한다.

```cpp
  // 파일 아카이브 생성 (쓰기 모드)
  if (TUniquePtr<FArchive> FileWriterAr = TUniquePtr<FArchive>(
          IFileManager::Get().CreateFileWriter(*FilePath)))
  {
      // 여러 개의 학생을 저장한다고 가정
      int32 Count = Students.Num();
      *FileWriterAr << Count;  // 먼저 객체 개수 기록

      for (UStudent* S : Students)
      {
          // 객체 자체를 아카이브에 직렬화
          S->Serialize(*FileWriterAr);
      }

      FileWriterAr->Close();
  }
```


### JSON 직렬화
JSON은 텍스트 포맷이라 `문법`과 `인코딩`이 중요하다.

언리얼에서는 보통
  1. FJsonObject (Key-Value 트리 구조)
  2. FJsonSerializer로 직렬화
  3. 문자열(JSON 텍스트)
  4. 파일 저장
흐름을 따른다.

장점
- 타입/구조 보존: FJsonObject는 Key-Value, 배열 등을 안전하게 표현
- 인코딩 처리 자동화: 내부 문자열(UTF-16 등)을 UTF-8/UTF-16 JSON 텍스트로 변환
- 편의성: FJsonObjectConverter가 UObject/UStruct <-> Json 자동 매핑을 제공

>> DOM(FJsonObject) 없이 스트리밍 API(TJsonWriter)로 바로 문자열을 쓰는 것도 가능하다. 하지만 FJsonObjectConverter 같은 도구는 DOM 경유를 전제로 만들어져 있어 그 방식을 따르는 게 일반적이다.