---
title: 언리얼 인터페이스
date: 2025-03-17 18:40:00 +09:00
categories: [Unreal, 언리얼 c++의 이해]
published: true
tags:
  [unreal, cpp, interface]
---

## **인터페이스**
**인터페이스(Interface)**는 클래스들이 공통으로 가져야할 기능(함수)을 정의하는 일종의 계약이다. 인터페이스를 통해 객체에게 꼭 구현해야하는 함수를 정의할 수 있다. 이는 특정 함수를 서로 다른 대규모의 복잡한 클래스에서 공유할 수 있게 한다.

### 인터페이스의 특징
1. 공통 부모 클래스가 없을 때도 공통 기능을 부여할 수 있다.
    다중 상속의 장점을 살려서 서로 상속 트리가 다른 클래스들끼리도 동일한 기능을 **약속**시킬 수 있다. 예를 들어, Moster, Door 가 전혀 다른 부모를 가졌지만, 다 같이 **열 수 있다(Open)**라는 기능을 갖게 하고 싶다면 IOpenable 인터페이스를 상속시키면 된다.

2. 특정 기능(함수) 구현을 강제할 수 있다.  
    가상 함수를 이용하여 함수를 정의하면 인터페이스를 상속받은 클래스들에게 해당 함수의 구현을 강제할 수 있다.

3. 코드 의존성 역전 (DIP)  
    특정 구현체가 아니라 "인터페이스 타입"에 의존하게 하여, 나중에 새로운 클래스를 추가하거나 교체해도 코드 수정이 최소화된다.


## **인터페이스 사용**

### **C++ 전용 인터페이스 함수**

#### 선언
```cpp
// Interactable.h
#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "Interactable.generated.h"

UINTERFACE(MinimalAPI)
class UInteractable : public UInterface
{
	GENERATED_BODY()
};

/* 실제 인터페이스 선언. */
class UNREALPRAC_API IInteractable
{
	GENERATED_BODY()

public:

	virtual void Interact(AActor* Interactor) = 0;
};

```

- UInteractable 클래스는 리플렉션 시스템 비저빌리티에 대한 빈 클래스이다. 
- 실제 인터페이스는 IInteractable 클래스로 `I`의 접두사를 갖고, 인터페이스 함수를 포함한다.

> 인터페이스 지정자
`Blueprintable` - 블루프린트에서 구현할 수 있도록 이 인터페이스를 노출시킵니다.
`BlueprintType` - 이 클래스를 블루프린트의 변수에 사용할 수 있는 타입으로 노출합니다.
`DependsOn=(ClassName1, ClassName2, ...)` - 빌드 시스템에서 이 클래스를 컴파일하기 전에 이 지정자로 나열된 모든 클래스를 컴파일합니다. 
`MinimalAPI` - 다른 모듈에서 사용하도록 클래스의 타입 정보만 익스포트합니다. 클래스는 캐스팅될 수 있지만 인라인 메서드를 제외하면 클래스의 함수는 호출될 수 없습니다.
{: .prompt-tip }

#### 구현

```cpp
// Door.h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Interactable.h"
#include "Door.generated.h"

UCLASS()
class UNREALPRAC_API ADoor : public AActor, public IInteractable
{
	GENERATED_BODY()
	
public:	
	ADoor();

// ...생략

public:
	virtual void Interact(AActor* Interactor) override;

};
```

```cpp
// Door.cpp
#include "Door.h"

ADoor::ADoor()
{
	PrimaryActorTick.bCanEverTick = true;

}

// ...생략

void ADoor::Interact(AActor* Interactor)
{
	UE_LOG(LogTemp, Log, TEXT("문이 열립니다"));
}

```

- 인터페이스 헤더 파일을 포함한 뒤, `I` 접두사 인터페이스 클래스를 상속한다.
- 함수를 오버라이드하여 다형성을 구현한다.
- 이 방식으로 선언된 C++ 인터페이스 함수는 블루프린트에 표시되지 않고 블루프린트 인터페이스에 사용할 수 없다.

#### 사용
```cpp
    if (IInteractable* Interactable = Cast<IInteractable>(Target))
    {
        // 여기서 문, 상자, NPC 전부 같은 코드로 실행됨
        Interactable->Interact(this);
    }
    else
    {
        UE_LOG(LogTemp, Log, TEXT("%s 은(는) 인터랙트 불가"), *GetNameSafe(Target));
    }
```
- Target을 Cast하여 각 객체에 맞는 함수를 호출한다.

### **블루프린트 구현 가능 인터페이스**

블루프린트 호출 가능 인터페이스 함수를 만들려면 `BlueprintCallable`지정자를 사용하여 함수의 선언에서 `UFUNCTION` 매크로를 지정하고, `BlueprintImplementableEvent` 또는 `BlueprintNativeEvent` 지정자를 사용해야 한다.

#### 선언
```cpp

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "Interactable.generated.h"

UINTERFACE(MinimalAPI, Blueprintable)
class UNREALPRAC_API UInteractable : public UInterface
{
    GENERATED_BODY()
};

class UNREALPRAC_API IInteractable
{
    GENERATED_BODY()

public:
    UFUNCTION(BlueprintCallable, BlueprintImplementableEvent, Category="Interact")
    void Interact(AActor* Interactor);
};
```

- `BlueprintImplementableEvent` 지정자를 사용할 경우 블루프린트에서만 구현될 수 있다.


```cpp

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "Interactable.generated.h"

UINTERFACE(MinimalAPI, Blueprintable)
class UNREALPRAC_API UInteractable : public UInterface
{
    GENERATED_BODY()
};

class UNREALPRAC_API IInteractable
{
    GENERATED_BODY()

public:
    UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category="Interact")
    void Interact(AActor* Interactor);
};
```

- `BlueprintNativeEvent` 지정자를 사용할 경우 C++ 또는 블루프린트에서 구현될 수 있다.

#### 구현

```cpp
// Door.h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Interactable.h"
#include "Door.generated.h"

UCLASS(Blueprintable)
class UNREALPRAC_API ADoor : public AActor, public IInteractable
{
	GENERATED_BODY()
	
public:	
	ADoor();

// ...생략

public:
    // 블루프린트 네이티브 이벤트 오버라이드
	void Interact_Implementation(AActor* Interactor) override;

};

```

```cpp
// Door.cpp
#include "Door.h"

ADoor::ADoor()
{
	PrimaryActorTick.bCanEverTick = true;

}

// ...생략

// 블루프린트 네이티브 이벤트 오버라이드 구현
void ADoor::Interact_Implementation(AActor* Interactor) 
{
	UE_LOG(LogTemp, Log, TEXT("문이 열립니다"));
}

```

- `BlueprintNativeEvent` 구현은 반드시 원형과 똑같은 시그니처로 _Implementation을 오버라이드해야 한다.

#### C++에서 블루프린트 이벤트 호출하기
C++의 `Blueprintable` 인터페이스에서 `BlueprintImplementableEven`t 또는 `BlueprintNativeEvent`를 안전하게 호출하기 위해 특수 스태틱 `Execute_` 함수 래퍼를 사용해야 한다. 

`Execute_` 함수는 내부적으로 BP 구현 있으면 ProcessEvent 호출, 없으면 _Implementation 호출한다.

```cpp
// C++ 또는 블루프린트에서 구현되었는지 여부와 무관하게 작동한다
IInteractable::Execute_Interact(Target, this);
```

| 인터페이스 타입 | 구현                                                                                                                | 호출 방법                                   |
| -------- | ----------------------------------------------------------------------------------------------------------------- | --------------------------------------- |
| C++ 전용   | 순수가상함수 → C++ override                                                                                             | `Cast<IInterface>(Target)->Func(...)`   |
| BP 연동    | `BlueprintNativeEvent` → C++ `Func_Implementation`, BP에서도 override 가능<br>`BlueprintImplementableEvent` → BP에서만 구현 | `IInterface::Execute_Func(Target, ...)` |



## 인터페이스 함수 타입
![alt text](/assets/img/unreal/인터페이스/image.png)