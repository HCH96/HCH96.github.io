---
title: 언리얼 엔진의 메모리 관리
date: 2025-09-22 18:40:00 +09:00
categories: [Unreal, 언리얼 c++의 이해]
published: true
tags:
  [unreal, cpp]
---

## c++ 메모리 관리의 문제점
C++에서는 저수준 메모리 제어가 가능하도록 포인터를 사용해 오브젝트를 직접 관리한다. 이 때문에 프로그래머가 new로 메모리를 할당하고 delete로 해제하는 과정을 빠뜨리면 다양한 문제가 발생할 수 있다.  

- 메모리 누수 (Memory Leak): 할당한 메모리를 해제하지 않아 힙 영역에 사용되지 않는 메모리가 쌓이는 문제.

- 댕글링 포인터 (Dangling Pointer): 이미 해제된 메모리를 여전히 참조하고 있어, 무효화된 주소를 가리키는 문제.

- 와일드 포인터 (Wild Pointer): 초기화되지 않은 포인터가 엉뚱한 메모리를 가리키는 문제.

이처럼 잘못된 포인터는 프로그램 동작을 예측할 수 없게 만들고, 심한 경우 프로그램이 비정상적으로 종료되기도 한다. 특히 게임처럼 규모가 크고 복잡한 소프트웨어에서는 이러한 실수의 가능성이 더욱 커진다.

언리얼 엔진은 이러한 위험을 줄이기 위해 메모리 관리 기능을 엔진 차원에서 제공하여, 프로그래머가 직접 포인터 관리에 신경 쓰지 않고도 안정적인 개발을 할 수 있도록 지원한다.

## 가비지 컬렉션
가비지 컬렉션은 프로그램에서 더 이상 사용하지 않는 오브젝트를 자동으로 감지하고 메모리를 회수하는 시스템이다. 이를 통해 개발자가 직접 메모리 해제를 처리하지 않아도 되어, 메모리 누수나 댕글링 포인터 같은 문제를 예방할 수 있다.

가비지 컬렉션은 보통 모든 동적 오브젝트 정보를 보관하는 저장소를 기반으로 동작하며, 사용되지 않는 메모리를 추적해 정리한다.

### 언리얼 엔진의 방식: 마크-스윕(Mark-Sweep)
언리얼 엔진은 자체적으로 구축한 마크-스윕 방식의 가비지 컬렉션을 사용한다. 동작 과정은 다음과 같다.

1. 루트 오브젝트 탐색
  - 저장소에서 검색을 시작할 루트 오브젝트를 찾는다.

2. 마킹(Mark)
  - 루트 오브젝트가 참조하는 객체를 "사용 중"으로 마크한다.
  - 마크된 객체가 참조하는 다른 객체도 반복적으로 추적하며 마크한다.

3. 스윕(Sweep)
  - 모든 탐색이 끝나면 저장소에는 마크된 객체(사용 중)와 마크되지 않은 객체(미사용)가 구분된다.
  - 가비지 컬렉터는 마크되지 않은 객체를 회수하여 메모리를 정리한다.

언리얼의 가비지 컬렉션은 주기적으로 자동 실행되며, 성능 최적화를 위해 병렬 처리, 클러스터링과 같은 기능이 함께 적용된다.

> 언리얼에서는 UObject와 UPROPERTY()로 관리되는 객체만 GC 대상이다. (일반 new/delete는 여전히 직접 관리해야 함) 또한 Unreal은 GC 외에도 TSharedPtr, TWeakPtr 같은 스마트 포인터 기반 메모리 관리 기능을 제공한다.
{: .prompt-tip }

### GUObjectArray와 플래그

언리얼 엔진은 전역 변수인 **GUObjectArray**에 모든 오브젝트의 정보를 보관한다.
각 요소에는 플래그가 설정되어 있으며, 대표적으로 다음과 같은 플래그가 있다.

- Garbage 플래그
  - 다른 언리얼 오브젝트로부터 참조되지 않아, GC가 회수 대상으로 판단한 오브젝트에 붙는다.
  - 프로그래머가 수동으로 지정하는 것이 아니라 시스템이 자동으로 설정한다.

- RootSet 플래그
  - 참조가 없더라도 절대 회수되지 않아야 하는 특별한 오브젝트에 붙는다.
  - AddToRoot() 함수로 설정할 수 있고, RemoveFromRoot() 함수로 제거할 수 있다.(권장되지 않음)

### 메모리 문제와 언리얼의 해결 방식

언리얼의 메모리 관리 시스템은 전통적인 C++의 메모리 문제를 완화한다.

- 메모리 누수
  - 언리얼 오브젝트는 GC에 의해 자동으로 해제된다.
  - C++ 오브젝트는 직접 관리해야 하므로, 가능하면 스마트 포인터를 활용하는 것이 좋다.

- 댕글링 포인터
  - 언리얼 오브젝트 포인터는 IsValid() 함수를 통해 유효성을 확인할 수 있다.
  - C++ 오브젝트는 직접 신경 써야 한다.

- 와일드 포인터
  - UPROPERTY()로 선언된 언리얼 오브젝트 포인터는 자동으로 nullptr로 초기화되어 안전하다.

### 올바른 참조 관리 원칙

언리얼에서 참조가 유지되는 경우는 크게 세 가지다.

1. UPROPERTY()로 선언된 오브젝트
2. AddReferencedObject()를 통해 참조가 등록된 오브젝트
3. RootSet에 등록된 오브젝트

따라서 오브젝트 포인터는 가급적 UPROPERTY로 선언하여, GC가 자동으로 추적·관리할 수 있도록 맡기는 것이 기본 원칙이다.

만약 UPROPERTY를 사용할 수 없는 일반 클래스에서 언리얼 오브젝트를 관리해야 한다면,
FGCObject를 상속받아 `AddReferencedObjects()` 함수를 구현함으로써 관리할 오브젝트를 직접 등록할 수 있다.

## 코드 실습

### StudentManager.h
```cpp
#pragma once
#include "CoreMinimal.h"

class UNREALMEMORY_API FStudentManager : public FGCObject
{
public:
    FStudentManager(class UStudent* InStudent) : SafeStudent(InStudent) {}

    virtual void AddReferencedObjects(FReferenceCollector& Collector) override;

    virtual FString GetReferencerName() const override
    {
        return TEXT("FStudentManager");
    }

    const class UStudent* GetStudent() const { return SafeStudent; }

private:
    class UStudent* SafeStudent = nullptr;
};
```

### StudentManager.cpp
```cpp
#include "StudentManager.h"
#include "Student.h"

void FStudentManager::AddReferencedObjects(FReferenceCollector& Collector)
{
    if (SafeStudent->IsValidLowLevel())
    {
        Collector.AddReferencedObject(SafeStudent);
    }
}
```

### MyGameInstance.h

```cpp
#pragma once
#include "CoreMinimal.h"
#include "Engine/GameInstance.h"
#include "MyGameInstance.generated.h"

UCLASS()
class UNREALMEMORY_API UMyGameInstance : public UGameInstance
{
    GENERATED_BODY()

public:
    virtual void Init() override;
    virtual void Shutdown() override;

private:
    TObjectPtr<class UStudent> NonPropStudent;

    UPROPERTY()
    TObjectPtr<class UStudent> PropStudent;

    TArray<TObjectPtr<class UStudent>> NonPropStudents;

    UPROPERTY()
    TArray<TObjectPtr<class UStudent>> PropStudents;

    class FStudentManager* StudentManager = nullptr;
};

```

### MyGameInstance.cpp

```cpp
#include "MyGameInstance.h"
#include "Student.h"
#include "StudentManager.h"

void CheckUObjectIsValid(const UObject* InObject, const FString& InTag)
{
    if (InObject->IsValidLowLevel())
    {
        UE_LOG(LogTemp, Log, TEXT("[%s] 유효한 언리얼 오브젝트"), *InTag);
    }
    else
    {
        UE_LOG(LogTemp, Log, TEXT("[%s] 유효하지 않은 언리얼 오브젝트"), *InTag);
    }
}

void CheckUObjectIsNull(const UObject* InObject, const FString& InTag)
{
    if (nullptr == InObject)
    {
        UE_LOG(LogTemp, Log, TEXT("[%s] 널 포인터 언리얼 오브젝트"), *InTag);
    }
    else
    {
        UE_LOG(LogTemp, Log, TEXT("[%s] 널 포인터가 아닌 언리얼 오브젝트"), *InTag);
    }
}

void UMyGameInstance::Init()
{
    Super::Init();

    NonPropStudent = NewObject<UStudent>();
    PropStudent = NewObject<UStudent>();

    NonPropStudents.Add(NewObject<UStudent>());
    PropStudents.Add(NewObject<UStudent>());

    StudentManager = new FStudentManager(NewObject<UStudent>());
}

void UMyGameInstance::Shutdown()
{
    Super::Shutdown();

    const UStudent* StudentInManager = StudentManager->GetStudent();

    delete StudentManager;
    StudentManager = nullptr;

    CheckUObjectIsNull(StudentInManager, TEXT("StudentInManager"));
    CheckUObjectIsValid(StudentInManager, TEXT("StudentInManager"));

    CheckUObjectIsNull(NonPropStudent, TEXT("NonPropStudent"));
    CheckUObjectIsValid(NonPropStudent, TEXT("NonPropStudent"));

    CheckUObjectIsNull(PropStudent, TEXT("PropStudent"));
    CheckUObjectIsValid(PropStudent, TEXT("PropStudent"));

    CheckUObjectIsNull(NonPropStudents[0], TEXT("NonPropStudents"));
    CheckUObjectIsValid(NonPropStudents[0], TEXT("NonPropStudents"));

    CheckUObjectIsNull(PropStudents[0], TEXT("PropStudents"));
    CheckUObjectIsValid(PropStudents[0], TEXT("PropStudents"));
}

```

### 결과

![alt text](/assets/img/unreal/메모리관리/image.png)

- NonPropStudent, NonPropStudents
  - `UPROPERTY`가 없으므로 GC가 추적하지 못해 루트에서 도달 불가능하다.
  - 따라서 GC 주기에 수거되어 파괴되고, 멤버 변수에는 이전 주소값만 남아 `댕글링 포인터`가 된다.
- PropStudent , PropStudents
  - `UPROPERTY`로 선언되어 GC 참조 그래프에 등록된다.
  - 루트에서 도달 가능한 상태로 인식되어 마크 단계에서 살아 있는 객체로 표시되고, 스윕 단계에서도 수거되지 않는다.
  - 따라서 여전히 유효한 오브젝트로 남는다.

- StudentManager
  - StudentManager는 FGCObject를 상속받고 AddReferencedObjects()에서 SafeStudent를 등록했기 때문에, 내부에서 관리하는 StudentInManager 객체가 GC 대상에서 제외된다.
  - 따라서 GC 주기가 와도 객체가 수거되지 않고, 여전히 널도 아니고 유효한 UObject로 남게 된다.