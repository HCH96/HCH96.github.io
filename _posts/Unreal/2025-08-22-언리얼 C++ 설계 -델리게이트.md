---
title: 언리얼 델리게이트
date: 2025-08-22 18:40:00 +09:00
categories: [Unreal, 언리얼 c++의 이해]
published: true
tags:
  [unreal, cpp, delegate]
---

## **강한 결합 (Strong Coupling)**
- 한 클래스가 다른 클래스의 구체적인 구현체에 직접 의존하는 경우
- 한쪽의 변경이 다른 클래스에 연쇄적으로 영향을 주는 구조

```cpp
class Card { 
public:
    bool Verify() { return true; }
};

class Person {
private:
    Card MyCard; // 강한 결합
public:
    bool Check() { return MyCard.Verify(); }
};
```
- Person 클래스는 Card 클래스에 대한 의존성이 있다.
- Card가 아닌 다른 인증 시스템이 필요한 경우 Person의 자식 클래스들에 대한 수정이 필요하다.

## **느슨한 결합 (Loose Coupling)**
- 클래스가 구체적인 구현체가 아니라 **추상화(인터페이스, 델리게이트)**에 의존하는 구조
- 실제 구현체는 외부에서 주입(Injection)하거나 교체 가능 → 확장성과 유지보수성 ↑

### **인터페이스**를 통한 느슨한 결합
```cpp
class ICheck {
public:
    virtual bool Verify() = 0;
    virtual ~ICheck() = default;
};

class Card : public ICheck {
public:
    bool Verify() override { return true; }
};

class FingerPrint : public ICheck {
public:
    bool Verify() override { return true; }
};

class Person {
private:
    ICheck* Checker; // 느슨한 결합
public:
    Person(ICheck* InChecker) : Checker(InChecker) {}
    bool Check() { return Checker->Verify(); }
};
```
- Person이 Card라는 구현체가 아닌 ICheck라는 **추상적 개념**에 의존한다.
- 만약 인증 방식이 카드 → 지문 → 홍채 등으로 바뀌어도 Person은 수정할 필요가 없다.

### **델리게이트**를 통한 느슨한 결합
느슨한 결합을 위해 추상적 개념을 계속해서 인터페이스로 정의한다면, 새로운 기능마다 인터페이스를 만들고 상속 구조를 늘려야 하므로 비효율적일 수 있다.

이때 **델리게이트(Delegate)**를 사용하면 함수를 오브젝트처럼 관리할 수 있어, 별도의 인터페이스 계층을 만들지 않고도 느슨한 결합을 유지할 수 있다.

- 델리게이트는 콜백(Callback) 메커니즘을 객체 지향적으로 구현한 것
- 기존 C++에서는 함수 포인터를 활용해 콜백을 구현
- 언리얼 엔진은 이를 더 안전하고 편리하게 다룰 수 있도록 델리게이트 시스템을 제공

```cpp
#include <iostream>
#include <functional>

struct Card {
    int Id = 0;
    bool CardCheck() { return true; }
};

// 델리게이트 타입 (리턴: bool, 인자: 없음)
using CheckDelegate = std::function<bool()>;

struct Person {
    CheckDelegate Check;

    Person(CheckDelegate InCheckDelegate)
        : Check(InCheckDelegate) {}
};
```

- Check는 콜백을 저장하는 멤버 변수로, 함수 포인터와 객체까지 다룰 수 있는 함수 객체
- Person은 CheckDelegate를 멤버로 들고, 생성자에서 주입받아 Check에 저장

### 인터페이스 기반 설계와 함수(콜백/델리게이트) 기반 설계의 차이

1. 인터페이스 기반 설계

- 새로운 기능이 필요할 때마다 ICheck, ISave, ILoad 같은 새로운 인터페이스를 계속 만들어야 한다.
- 객체지향의 "추상화"를 잘 표현할 수 있지만, 구조가 무거워지고 클래스 파일이 늘어난다.
- 주로 "객체 간에 여러 책임을 정형화해서 공유"할 때 사용한다.

2. 함수(콜백/델리게이트) 기반 설계

- "추상적 설계" = 사실상 특정 시점에 어떤 동작을 실행할지만 필요한 경우, 굳이 새 인터페이스 만들지 말고 **함수 시그니처(= 함수 포인터/델리게이트)**만 정의하면 된다.
- 코드가 훨씬 짧고 가볍고, 런타임에 바꾸기도 편하다.


## 언리얼에서의 델리게이트
- 동적 바인딩
  델리게이트는 임의 오브젝트의 멤버 함수를 런타임에 동적으로 바인딩할 수 있다. 함수를 호출하는 쪽에서는 해당 오브젝트의 구체적인 유형을 몰라도 함수를 실행할 수 있다.

- 복사 안정성
  델리게이트 객체는 복사해도 안전하다. 내부적으로 함수 포인터와 객체 정보를 관리하기 때문에, 복사된 델리게이트도 동일한 동작을 보장한다.

- 값 전달 vs 참조 전달
  델리게이트는 값으로 전달할 수 있지만, 힙 메모리 할당이 발생하기 때문에 성능상 이슈가 생길 수 있다. 따라서 특별한 이유가 없다면, 항상 참조로 전달하는 것이 권장된다.

### 델리게이트 선언하기

- 언리얼에서 델리게이트의 선언은 제공되는 선언 매크로를 사용하여 이루어진다. 
- 어떤 매크로를 쓸지는 델리게이트에 바인딩할 함수의 시그너처(반환값, 파라미터 개수/타입)에 따라 달라진다.
- 엔진은 미리 다양한 함수 시그너처 조합을 지원하는 매크로를 정의해두었기 때문에, 개발자는 필요한 반환값과 파라미터 타입만 채워 넣으면 된다.
- 델리게이트 시그니처 선언은 글로벌 영역, 네임스페이스 안, 클래스의 선언부 안(함수 본문은 제외)에 존재할 수 있다.

| 함수 시그니처                           | 선언 매크로                                                                 |
|-----------------------------------------|------------------------------------------------------------------------------|
| `void Function()`                       | `DECLARE_DELEGATE( DelegateName )`                                          |
| `void Function(<Param1>)`               | `DECLARE_DELEGATE_OneParam( DelegateName, Param1Type )`                     |
| `void Function(<Param1>, <Param2>)`     | `DECLARE_DELEGATE_TwoParams( DelegateName, Param1Type, Param2Type )`        |
| `void Function(<Param1>, <Param2>, ...)`| `DECLARE_DELEGATE_<Num>Params( DelegateName, Param1Type, Param2Type, ... )` |
| `<RetVal> Function()`                   | `DECLARE_DELEGATE_RetVal( RetValType, DelegateName )`                       |
| `<RetVal> Function(<Param1>)`           | `DECLARE_DELEGATE_RetVal_OneParam( RetValType, DelegateName, Param1Type )`  |
| `<RetVal> Function(<Param1>, <Param2>)` | `DECLARE_DELEGATE_RetVal_TwoParams( RetValType, DelegateName, Param1Type, Param2Type )` |
| `<RetVal> Function(<Param1>, <Param2>, ...)` | `DECLARE_DELEGATE_RetVal_<Num>Params( RetValType, DelegateName, Param1Type, Param2Type, ... )` |

- 여러 개의 객체가 동시에 같은 델리게이트에 바인딩될 경우, 바운드된 모든 함수가 순차적으로 호출됨 -> DECLARE_MULTICAST_DELEGATE...
- 블루프린트에서도 사용 가능한 델리게이트, 리플렉션 시스템에 등록되므로, 직렬화/저장/에디터 활용 가능 -> DECLARE_DYNAMIC_DELEGATE...
- 멀티캐스트 + 블루프린트 지원을 동시에 제공 -> DECLARE_DYNAMIC_MULTICAST_DELEGATE...


#### 예시
```cpp
void Function();
DECLARE_DELEGATE(DelegateName);


void Function(bool bValue);
DECLARE_DELEGATE_OneParam(DelegateName, bool);
```

### 델리게이트 바인딩

언리얼의 델리게이트 시스템은 특정 오브젝트 유형을 이해하고 있고,
UObject나 TSharedPtr 같은 객체에 바인딩할 때는 **약한 참조(Weak Reference)**를 유지한다.

따라서 대상 객체가 소멸되더라도, IsBound() 또는 ExecuteIfBound()로 안전하게 체크하고 실행할 수 있다.

| 함수                | 설명                                                                                   |
| ----------------- | ------------------------------------------------------------------------------------ |
| **Bind()**        | 기존 델리게이트 객체에 바인딩.                                                                    |
| **BindStatic()**  | 전역 함수(Static Function)를 델리게이트에 바인딩.                                                  |
| **BindRaw()**     | **Raw C++ 포인터**로 멤버 함수를 바인딩.<br>객체 소멸 시 안전 보장 없음 → `Execute()` 사용 시 주의 필요.           |
| **BindSP()**      | **Shared Pointer 기반 객체**의 멤버 함수 바인딩.<br>약한 레퍼런스를 유지하므로 `ExecuteIfBound()`로 안전 호출 가능. |
| **BindUObject()** | **UObject 기반 객체**의 멤버 함수 바인딩.<br>약한 레퍼런스를 유지하므로 `ExecuteIfBound()`로 안전 호출 가능.        |
| **UnBind()**      | 델리게이트 바인딩을 해제.                                                                       |


### 페이로드 데이터
페이로드는 델리게이트를 바인딩할 때 추가로 고정값을 전달하는 기능이다. 실행 시점에는 이 값이 자동으로 함수에 전달되므로, 매번 호출할 때 인자를 중복해서 넘겨줄 필요가 없다.
만약 델리게이트 함수의 인자가 객체의 ID와 같은 변하지 않는 값을 인자로 받고 해당 객체와 델리게이트를 바인딩할 때 페이로드 데이터를 이용해 고정값을 전달한다면 실행시에는 해당 인자를 넘기지 않아도 된다.

### 델리게이트 실행

- 델리게이트 실행 시 델리게이트는 `Execute()`를 호출하여 실행한다. 실행 전 반드시 바인딩 여부를 확인해야 한다.

- 델리게이트가 바인딩되지 않은 상태에서 실행되면, 반환값이나 출력 파라미터가 초기화되지 않아 메모리 오염(garbage write) 발생할 수 있고, 코드 안전성이 떨어진다.

| 실행 함수          | 설명 |
|--------------------|------|
| **Execute()**      | 델리게이트에 바인딩된 함수를 실행. 바인딩되지 않은 경우 크래시 위험이 있으므로 반드시 `IsBound()`로 확인 후 호출해야 함. |
| **ExecuteIfBound()** | 반환값이 없는 델리게이트에서만 사용 가능. 바인딩 여부를 자동으로 확인한 뒤 실행하므로 안전. 단, 출력 파라미터는 초기화되지 않을 수 있음. |
| **IsBound()**      | 델리게이트에 함수가 바인딩되어 있는지 검사. 실행 전 안전성 확인용으로 사용. |


### 언리얼 델리게이트 선언 시 고려사항

델리게이트를 설계할 때는 다음과 같은 요소들을 고려해야 한다.  

#### 1. 어떤 데이터를 전달하고 받을 것인가?
- 인자의 수와 각 인자의 타입을 어떻게 설계할 것인가?  
- 몇 개의 인자를 전달할 것인가?  
- 어떤 방식으로 전달할 것인가?  
  - **일대일 전달**  
  - **일대다 전달**  

#### 2. 프로그램 환경 설정
- 해당 델리게이트가 **C++ 프로그래밍에서만** 사용될 것인가?  
- 아니면 `UFUNCTION`을 이용해 **블루프린트 함수와도 연동**할 것인가?  

#### 3. 어떤 함수와 연결할 것인가?
- 클래스 외부에 정의된 C++ 함수와 연결  
- 전역에 설계된 정적 함수와 연결  
- 언리얼 오브젝트의 멤버 함수와 연결 (→ 대부분의 경우 이 방식을 사용)  


### 사용 예시
학사 정보가 변경되었을 때 자동으로 알림을 보내주는 학사정보 시스템을 델리게이트 기반의 느슨한 결합으로 구현.

```cpp
DECLARE_MULTICAST_DELEGATE_OneParam(FCourseInfoOnChangedSignature, const FString&);

UCLASS()
class UNREALSTUDY_API UCourseInfo : public UObject
{
	GENERATED_BODY()
	
public:
	UCourseInfo();

	FCourseInfoOnChangedSignature OnChanged;

	void ChangeCourseInfo(const FString& InNewContents);

private:
	FString Contents;

};
```

- 학사 정보 변경을 알릴 멀티캐스트 델리게이트를 선언한다.
- 학사 정보 시스템(UCourseInfo)은 이 델리게이트를 멤버 변수로 가진다.

```cpp
#include "CourseInfo.h"

UCourseInfo::UCourseInfo()
{
	Contents = TEXT("기존 학사 정보");

}

void UCourseInfo::ChangeCourseInfo(const FString& InNewContents)
{
	Contents = InNewContents;
	UE_LOG(LogTemp, Log, TEXT("[CourseInfo] 학사 정보가 변경되어 알림을 발송합니다."));
	OnChanged.Broadcast(InNewContents);
}

```
- 학사 정보가 변경되면 로그를 출력하고, OnChanged.Broadcast()로 바인딩된 모든 객체에 알린다.

```cpp

// .h
UCLASS()
class UNREALSTUDY_API UStudent : public UPerson, public ILessonInterface
{
	GENERATED_BODY()
	
public:
	UStudent();

	virtual void DoLesson() override;
	void GetNotification(const FString& NewCourseInfo);

};

// .cpp
void UStudent::GetNotification(const FString& NewCourseInfo)
{
	UE_LOG(LogTemp, Log, TEXT("[Student] %s님이 받은 메세지 : %s"), *Name, *NewCourseInfo);
}

```
- 학생(UStudent) 클래스는 알림을 받을 함수를 정의하고, 델리게이트에 바인딩될 수 있다.


```cpp
UCLASS()
class UNREALSTUDY_API UMyGameInstance : public UGameInstance
{
	GENERATED_BODY()
	
public:
	UMyGameInstance();

	virtual void Init() override;

private:
	UPROPERTY()
	TObjectPtr<class UCourseInfo> CourseInfo;

	UPROPERTY()
	FString SchoolName;
};
```
- 델리게이트를 가진 CourseInfo 객체를 멤버 변수로 선언

```cpp
void UMyGameInstance::Init()
{
	Super::Init();

	CourseInfo = NewObject<UCourseInfo>(this);

	UE_LOG(LogTemp, Log, TEXT("======================================================="));

	// 바인딩할 객체 생성
	UStudent* Student1 = NewObject<UStudent>();
	Student1->SetName(TEXT("학생1"));
	UStudent* Student2 = NewObject<UStudent>();
	Student1->SetName(TEXT("학생2"));
	UStudent* Student3 = NewObject<UStudent>();
	Student1->SetName(TEXT("학생3"));

	// 바인딩
	CourseInfo->OnChanged.AddUObject(Student1, &UStudent::GetNotification);
	CourseInfo->OnChanged.AddUObject(Student2, &UStudent::GetNotification);
	CourseInfo->OnChanged.AddUObject(Student3, &UStudent::GetNotification);

	CourseInfo->ChangeCourseInfo(TEXT("변경된 학사 정보");
	UE_LOG(LogTemp, Log, TEXT("======================================================="));
}

```
- UMyGameInstance에서 UCourseInfo와 UStudent들을 생성한다.
- 학생 객체들을 OnChanged 델리게이트에 바인딩한다.
- 학사 정보를 변경하면, 바인딩된 모든 학생 객체가 알림을 받는다.

- 클래스 정리
  CourseInfo: 알림을 발송하는 주체
  Student: 알림을 수신하는 객체
  Delegate: 둘을 직접 연결하지 않고, 중간 이벤트 허브 역할을 하여 느슨한 결합을 달성

#### 실행 결과
![alt text](/assets/img/unreal/델리게이트/image.png)