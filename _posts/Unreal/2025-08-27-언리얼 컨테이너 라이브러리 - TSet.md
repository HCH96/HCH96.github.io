---
title: 언리얼 컨테이너 라이브러리Ⅱ- TSet
date: 2025-08-27 18:40:00 +09:00
categories: [Unreal, 언리얼 c++의 이해]
published: true
tags:
  [unreal, cpp, tset]
---

## TSet
`TSet`은 순서가 중요하지 않은 고유한 값들을 빠르게 저장하고 검색,삭제할 수 있는 `해시 기반 컨테이너`이다. 따라서 중복 없는 데이터 모음을 빠르게 추가하고 검색하고 삭제하는 데 사용된다.
STL의 `set`과 비슷하지만, 값 자체가 키로 쓰이며 내부적으로 해시 테이블을 사용한다는 점이 특징이다.

### 특징
- TSet은 해시 기반 컨테이너라서 검색/삽입/삭제 속도가 빠르다.
- 기본적으로 중복 요소는 허용되지 않는다.
- TSet은 값 타입(value type) 으로 동작한다.
    - 즉, 복사/대입/소멸이 가능하고, 세트가 소멸되면 안에 있는 요소들도 함께 소멸된다.
- 메모리 배치는 TArray와 달리 연속적이지 않다.
    - 반복시, 원소가 삽입된 순서대로 나온다는 보장이 없다.
- 내부적으로는 인스턴스 사이에 빈 공간이 존재하는 희소 배열 구조라, 어떤 요소를 지우면 그 곳에 빈자리가 생기고, 다른 요소를 추가하면 해당 공간을 차지한다.


### TSet 사용법

#### **선언**

```cpp
    TSet<FString> FruitSet; // 빈 세트 (초기 할당 없음)
```
---

#### **추가**

```cpp
    FruitSet.Add(TEXT("Banana"));
    FruitSet.Add(TEXT("Grapefruit"));
    FruitSet.Add(TEXT("Pineapple"));

    FruitSet.Add(TEXT("Pear"));
    FruitSet.Add(TEXT("Banana"));
    // "Banana"는 이미 있으므로 항목 수는 증가하지 않음

    FruitSet.Emplace(TEXT("Orange"));

    TSet<FString> FruitSet2;
    FruitSet2.Emplace(TEXT("Kiwi"));
    FruitSet2.Emplace(TEXT("Melon"));
    FruitSet2.Emplace(TEXT("Mango"));
    FruitSet2.Emplace(TEXT("Orange"));

    FruitSet.Append(FruitSet2);

```
- 순서가 보장되지 않는다.
- 이미 존재하는 인스턴스의 경우 증가하지 않는다.
- `Emplace`의 경우 임시 객체를 생성하지 않는다.
- `Append` (세트 병합)는 두 개의 TSet을 합친다. 중복 항목은 대체된다.

---

#### **UPROPERTY로 에디터에서 편집**
```cpp
    UPROPERTY(Category=SetExample, EditAnywhere)
    TSet<FString> FruitSet;
```
- `UPROPERTY`, `EditAnywhere`를 통해 에디터에서 편집이 가능하다.

---

#### **반복**

1. 범위 기반 for문

```cpp
    for (const auto& Elem : FruitSet)
    {
        UE_LOG(LogTemp, Log, TEXT("%s"), *Elem);
    }
```

2. 이터레이터 기반 for문
```cpp
    for (auto It = FruitSet.CreateConstIterator(); It; ++It)
    {
        UE_LOG(LogTemp, Log, TEXT("(%s)"), **It); 
        // It은 포인터처럼 역참조하여 값 접근
    }
```
> TSet은 순서가 안정적이지 않다. 반복 순서에 의존하는 코드는 지양하는 것이 좋다.

#### **쿼리**

- `Num` : 인스턴스의 개수를 반환

```cpp
    int32 Count = FruitSet.Num();
```

---

- `Contains` : 인스턴스의 포함 여부
```cpp
    bool bHasBanana = FruitSet.Contains(TEXT("Banana"));
    bool bHasLemon  = FruitSet.Contains(TEXT("Lemon"));
```

- 인덱스 검색(`FSetElementId`) & `operator[]`

```cpp
    FSetElementId BananaId = FruitSet.Index(TEXT("Banana"));
    if (BananaId.IsValidId())
    {
        const FString& S = FruitSet[BananaId]; // const 세트면 const 참조 반환
    }
```

> 존재하지 않는 키의 Id(INDEX_NONE)로 operator[] 접근 시 Assert/오류가 발생한다.

---

- `Find` : 키를 기반으로 검색 후 포인터 반환
```cpp
    if (FString* PtrBanana = FruitSet.Find(TEXT("Banana")))
    {
        // *PtrBanana == "Banana"
    }
```

---
- Array로 복사
```cpp
    TArray<FString> FruitArray = FruitSet.Array();
    // 세트의 전체 '사본'을 TArray로 받음 (순서는 여전히 비보장)
```
---

#### **제거**

1. 키로 제거
```cpp
int32 Removed = FruitSet.Remove(TEXT("Pineapple")); // 없으면 0
```

2. 이터레이션 중 인덱스 제거 (특수 상황)
```cpp
FruitSet.Remove(FSetElementId::FromInteger(0)); // 반복 중에만 권장
```

3. 전체 제거
```cpp
TSet<FString> Copy = FruitSet;
Copy.Empty();    // 전부 제거 (슬랙 인자 받을 수 있음)
Copy.Reset();    // 전부 제거 (슬랙 최대한 유지)
```
- Empty와 Reset의 차이: Empty는 슬랙 크기를 지정 가능, Reset은 기존 할당(슬랙)을 최대한 유지.

---
#### **소팅**
TSet도 정렬 가능하지만, 세트 변경 시 정렬 순서는 보장되지 않는다. 또한 정렬은 불안정 정렬이다.

```cpp
FruitSet.Sort([](const FString& A, const FString& B){
    return A > B; // 역알파벳
});

FruitSet.Sort([](const FString& A, const FString& B){
    return A.Len() < B.Len(); // 길이 기준
});
```

---

#### **연산자 / 복사**
TSet은 값 타입이므로 깊은 복사가 이루어지고, 복사 후 한쪽을 수정해도 원본에 영향 없다.

```cpp
TSet<FString> NewSet = FruitSet;
NewSet.Add(TEXT("Apple"));
NewSet.Remove(TEXT("Pear"));
```


#### **슬랙(Slack)**

> 슬랙은 할당된 메모리 중 비어 있는 공간을 의미하며, 엘리먼트가 없더라도 메모리만 확보해 두거나 제거 후에도 메모리를 유지할 수 있다. 이를 적절히 활용하면 반복적인 삽입과 삭제 과정에서 발생하는 메모리 재할당 비용을 줄일 수 있다.
{: .prompt-tip }

- `Reserve`: 인스턴스가 들어갈 메모리를 미리 할당한다.
- `Reset` / `Empty`: 둘 다 모든 인스턴스를 제거하는 함수이지만, Empty는 맵에 남길 슬랙을 파라미터로 받을 수 있다. 반면에 Reset은 항상 최대한의 슬랙을 남긴다.
- `Shrink`: 컨테이너 끝부분의 슬랙만 제거.
- `Compact` / `CompactStable`: 모든 인스턴스를 압축한 뒤, `Shrink`를 통하여 모든 슬랙을 제거한다.
    - `CompactStable은` 요소 상대 순서 유지.

---

#### ** DefaultKeyFuncs (커스텀 키 정책) **

- 키 = 요소 자체
- 비교 = operator==
- 해시 = 전역 GetTypeHash(Key)

> 만약 타입에 operator==/GetTypeHash를 추가하고 싶지 않거나, 커스텀 키/해시/중복 정책이 필요하면 DefaultKeyFuncs<ElementType>를 상속/구현해 KeyFuncs 템플릿 인자로 제공하면 된다.