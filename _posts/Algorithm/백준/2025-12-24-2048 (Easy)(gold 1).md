---
title: 2048 (Easy)
date: 2025-12-24 18:00:00 +09:00
categories: [Algorithm, Baekjoon]
published: false
tags:
  [algorithm, simulation, recursive function]
---

[2048 (Easy)](https://www.acmicpc.net/problem/12100)

## Code

### 오답
```cpp
#include <iostream>
#include <bits/stdc++.h>
#include <sstream>

using namespace std;

int N, Answer;

void Check(const vector<vector<int>>& board)
{
    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < N; ++j)
        {
            if (board[i][j] > Answer)
            {
                Answer = board[i][j];
            }
        }
    }
}

void MoveRow(vector<vector<int>>& board, int CurRow, bool reverse)
{
    if (reverse)
    {
        int CurIdx = N - 1;

        for (int i = N - 1; i >= 0; --i)
        {
            if (board[CurRow][i] != 0)
            {
                int Tmp = board[CurRow][i];
                board[CurRow][i] = 0;
                board[CurRow][CurIdx--] = Tmp;
            }
        }
    }
    else
    {
        int CurIdx = 0;

        for (int i = 0; i < N; ++i)
        {
            if (board[CurRow][i] != 0)
            {
                int Tmp = board[CurRow][i];
                board[CurRow][i] = 0;
                board[CurRow][CurIdx++] = Tmp;
            }
        }
    }

}

void MoveCol(vector<vector<int>>& board, int CurCol, bool reverse)
{
    if (reverse)
    {
        int CurIdx = N - 1;

        for (int i = N - 1; i >= 0; --i)
        {
            if (board[i][CurCol] != 0)
            {
                int Tmp = board[i][CurCol];
                board[i][CurCol] = 0;
                board[CurIdx--][CurCol] = Tmp;
            }
        }
    }
    else
    {
        int CurIdx = 0;
        
        for (int i = 0; i < N; ++i)
        {
            if (board[i][CurCol] != 0)
            {
                int Tmp = board[i][CurCol];
                board[i][CurCol] = 0;
                board[CurIdx++][CurCol] = Tmp;
            }
        }
    }

}

void Move(vector<vector<int>>& board, int Dir)
{
    // 상
    if (Dir == 0)
    {
        for (int i = 0; i < N; ++i)
        {
            MoveCol(board, i, false);
        }
    }
    // 하
    else if (Dir == 1)
    {
        for (int i = 0; i < N; ++i)
        {
            MoveCol(board, i, true);
        }
    }
    // 좌
    else if (Dir == 2)
    {
        for (int i = 0; i < N; ++i)
        {
            MoveRow(board, i, false);
        }
    }
    // 우
    else if (Dir == 3)
    {
        for (int i = 0; i < N; ++i)
        {
            MoveRow(board, i, true);
        }
    }
}

void CompressRow(vector<vector<int>>& board, int CurRow, bool reverse)
{
    if (reverse)
    {
        for (int i = N - 2; i >= 0; i = i - 2)
        {
            if (board[CurRow][i] == board[CurRow][i + 1])
            {
                board[CurRow][i + 1] = board[CurRow][i + 1] * 2;
                board[CurRow][i] = 0;
            }
        }
    }
    else
    {
        for (int i = 1; i < N; i = i + 2)
        {
            if (board[CurRow][i] == board[CurRow][i - 1])
            {
                board[CurRow][i - 1] = board[CurRow][i - 1] * 2;
                board[CurRow][i] = 0;
            }
        }
    }
}

void CompressCol(vector<vector<int>>& board, int CurCol, bool reverse)
{
    if (reverse)
    {
        for (int i = N - 2; i >= 0; i = i - 2)
        {
            if (board[i][CurCol] == board[i + 1][CurCol])
            {
                board[i + 1][CurCol] = board[i + 1][CurCol] * 2;
                board[i][CurCol] = 0;
            }
        }
    }
    else
    {
        for (int i = 1; i < N; i = i + 2)
        {
            if (board[i][CurCol] == board[i-1][CurCol])
            {
                board[i-1][CurCol] = board[i-1][CurCol] * 2;
                board[i][CurCol] = 0;
            }
        }
    }
}

void Compress(vector<vector<int>>& board, int Dir)
{
    // 상
    if (Dir == 0)
    {
        for (int i = 0; i < N; ++i)
        {
            CompressCol(board, i, false);
        }
    }
    // 하
    else if (Dir == 1)
    {
        for (int i = 0; i < N; ++i)
        {
            CompressCol(board, i, true);
        }
    }
    // 좌
    else if (Dir == 2)
    {
        for (int i = 0; i < N; ++i)
        {
            CompressRow(board, i, false);
        }
    }
    // 우
    else if (Dir == 3)
    {
        for (int i = 0; i < N; ++i)
        {
            CompressRow(board, i, true);
        }
    }
}

void Proc(vector<vector<int>>& board, int Dir)
{
    Move(board, Dir);
    Compress(board, Dir);
    Move(board, Dir);
}


void DFS(int depth, const vector<vector<int>>& board)
{
    if (depth == 5)
    {
        Check(board);
        return;
    }

    for (int i = 0; i < 4; ++i)
    {
        vector<vector<int>> Tmp = board;

        Proc(Tmp, i);

        DFS(depth + 1, Tmp);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> N;

    vector<vector<int>> board(N, vector<int>(N));

    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < N; ++j)
        {
            cin >> board[i][j];
        }
    }

    DFS(0, board);

    cout << Answer;
  
    return 0;
}
```

### 정답
```cpp
#include <iostream>
#include <bits/stdc++.h>
#include <sstream>

using namespace std;

int N, Answer;

void Check(const vector<vector<int>>& board)
{
    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < N; ++j)
        {
            if (board[i][j] > Answer)
            {
                Answer = board[i][j];
            }
        }
    }
}

void MoveRow(vector<vector<int>>& board, int CurRow, bool reverse)
{
    if (reverse)
    {
        int CurIdx = N - 1;

        for (int i = N - 1; i >= 0; --i)
        {
            if (board[CurRow][i] != 0)
            {
                int Tmp = board[CurRow][i];
                board[CurRow][i] = 0;
                board[CurRow][CurIdx--] = Tmp;
            }
        }
    }
    else
    {
        int CurIdx = 0;

        for (int i = 0; i < N; ++i)
        {
            if (board[CurRow][i] != 0)
            {
                int Tmp = board[CurRow][i];
                board[CurRow][i] = 0;
                board[CurRow][CurIdx++] = Tmp;
            }
        }
    }

}

void MoveCol(vector<vector<int>>& board, int CurCol, bool reverse)
{
    if (reverse)
    {
        int CurIdx = N - 1;

        for (int i = N - 1; i >= 0; --i)
        {
            if (board[i][CurCol] != 0)
            {
                int Tmp = board[i][CurCol];
                board[i][CurCol] = 0;
                board[CurIdx--][CurCol] = Tmp;
            }
        }
    }
    else
    {
        int CurIdx = 0;
        
        for (int i = 0; i < N; ++i)
        {
            if (board[i][CurCol] != 0)
            {
                int Tmp = board[i][CurCol];
                board[i][CurCol] = 0;
                board[CurIdx++][CurCol] = Tmp;
            }
        }
    }

}

void Move(vector<vector<int>>& board, int Dir)
{
    // 상
    if (Dir == 0)
    {
        for (int i = 0; i < N; ++i)
        {
            MoveCol(board, i, false);
        }
    }
    // 하
    else if (Dir == 1)
    {
        for (int i = 0; i < N; ++i)
        {
            MoveCol(board, i, true);
        }
    }
    // 좌
    else if (Dir == 2)
    {
        for (int i = 0; i < N; ++i)
        {
            MoveRow(board, i, false);
        }
    }
    // 우
    else if (Dir == 3)
    {
        for (int i = 0; i < N; ++i)
        {
            MoveRow(board, i, true);
        }
    }
}

void CompressRow(vector<vector<int>>& board, int CurRow, bool reverse)
{
    if (reverse)
    {
        int CurIdx = N - 2;
        while (CurIdx >= 0)
        {
            if (board[CurRow][CurIdx] == board[CurRow][CurIdx+1])
            {
                board[CurRow][CurIdx+1] *= 2;
                board[CurRow][CurIdx] = 0;
                CurIdx -= 2;
            }
            else
            {
                --CurIdx;
            }
        }
    }
    else
    {
        int CurIdx = 1;
        while (CurIdx < N)
        {
            if (board[CurRow][CurIdx] == board[CurRow][CurIdx-1])
            {
                board[CurRow][CurIdx-1] = board[CurRow][CurIdx-1] * 2;
                board[CurRow][CurIdx] = 0;
                CurIdx += 2;
            }
            else
            {
                ++CurIdx;
            }
        }
    }
}

void CompressCol(vector<vector<int>>& board, int CurCol, bool reverse)
{
    if (reverse)
    {
        int CurIdx = N - 2;
        while (CurIdx >= 0)
        {
            if (board[CurIdx][CurCol] == board[CurIdx + 1][CurCol])
            {
                board[CurIdx + 1][CurCol] *= 2;
                board[CurIdx][CurCol] = 0;
                CurIdx -= 2;
            }
            else
            {
                --CurIdx;
            }
        }
    }
    else
    {
        int CurIdx = 1;
        while (CurIdx < N)
        {
            if (board[CurIdx][CurCol] == board[CurIdx-1][CurCol])
            {
                board[CurIdx - 1][CurCol] = board[CurIdx - 1][CurCol] * 2;
                board[CurIdx][CurCol] = 0;
                CurIdx += 2;
            }
            else
            {
                ++CurIdx;
            }
        }
    }
}

void Compress(vector<vector<int>>& board, int Dir)
{
    // 상
    if (Dir == 0)
    {
        for (int i = 0; i < N; ++i)
        {
            CompressCol(board, i, false);
        }
    }
    // 하
    else if (Dir == 1)
    {
        for (int i = 0; i < N; ++i)
        {
            CompressCol(board, i, true);
        }
    }
    // 좌
    else if (Dir == 2)
    {
        for (int i = 0; i < N; ++i)
        {
            CompressRow(board, i, false);
        }
    }
    // 우
    else if (Dir == 3)
    {
        for (int i = 0; i < N; ++i)
        {
            CompressRow(board, i, true);
        }
    }
}

void Proc(vector<vector<int>>& board, int Dir)
{
    Move(board, Dir);
    Compress(board, Dir);
    Move(board, Dir);
}

void DFS(int depth, const vector<vector<int>>& board)
{
    if (depth == 5)
    {
        Check(board);
        return;
    }

    for (int i = 0; i < 4; ++i)
    {
        vector<vector<int>> Tmp = board;

        Proc(Tmp, i);

        DFS(depth + 1, Tmp);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> N;

    vector<vector<int>> board(N, vector<int>(N));

    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < N; ++j)
        {
            cin >> board[i][j];
        }
    }

    DFS(0, board);

    cout << Answer;
  
    return 0;
}
```


## 문제 해석

이 문제는 유명한 2048 게임을 그대로 구현한 시뮬레이션 문제다.

- N × N 보드가 주어진다.
- 한 번의 이동에서 상 / 하 / 좌 / 우 중 하나로 보드를 민다.
- 같은 숫자가 이동 방향 기준으로 만나면 한 번만 합쳐진다.
- 최대 5번 이동해서 만들 수 있는 가장 큰 숫자를 구한다.

핵심 조건은 두 가지다.

- 이동은 정확히 2048 규칙을 따라야 한다.
- 이동 횟수는 최대 5번으로 매우 작다.


## 문제 접근

### 완전 탐색
한 상태에서 가능한 이동은 4가지 최대 깊이는 5 경우의 수는 4^5 = 1024 즉, 모든 경우를 다 만들어봐도 1024개뿐이다.
각 상태마다 N×N 보드를 들고 있어도 (N ≤ 20) 메모리도, 시간도 전혀 문제 되지 않는다.

> DFS로 모든 이동 시퀀스를 만들고, 깊이가 5가 되면 보드에서 최댓값을 갱신한다.

### 백트래킹의 필요성
여기서 한 번 고민이 생겼다. “같은 보드 상태가 여러 번 나오면 백트래킹(visited 처리)을 해야 하나?”

전체 경우의 수가 1024에 불과하고 상태 중복을 체크하려면 보드 해시/비교 로직이 들어가야 해서 오히려 코드만 복잡해진다.
그래서 선택한 방식은 단순하다.

```text
DFS(depth, board)
  if depth == 5:
    answer 갱신
  else:
    for dir in 4방향:
      nextBoard = board 복사
      이동 수행
      DFS(depth + 1, nextBoard)
```
board는 const reference로 받고, 다음 상태만 복사해서 넘긴다.

### 이동 로직

#### 처음 생각했던 로직
1. 먼저 0을 제거해서 한쪽으로 이동한다.
2. (0,1), (2,3)처럼 두 칸씩 비교해서 합친다.
3. 다시 한 번 같은 방향으로 한쪽으로 이동한다.

```text
[2, 4, 4, 0]  (왼쪽 이동)
```
하지만 이 방법은 (0,1), (2,3)과 같이 짝을 지어서만 합치기 때문에 (1,2)는 합쳐지지 않는 오류가 있었다.
위와 같은 반례에서 정답은 8이지만 4가 나오게된다.

#### 수정 로직
1. 이동 방향 기준으로 0을 제거한다.
2. 앞에서부터 한 칸씩 보면서 같은 값이면 합친다. 합친 칸은 이번 이동에서 다시 합쳐지면 안되기 때문에,
 - 만약 같은 값일 경우 2칸을 건너뛴다.
 - 만약 다른 값일 경우 1칸을 건너뛴다.
3. 다시 한 번 같은 방향으로 한쪽으로 이동한다.


## 틀렸던 이유

합치기 로직을 “짝 고정”으로 생각했다. (0,1), (2,3) 방식은 일반화되지 않는다. 2048은 항상 인접한 칸 기준이다.

