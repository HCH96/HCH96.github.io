---
title: 배열 정렬(Gold 1)
date: 2025-12-23 03:40:00 +09:00
categories: [Algorithm, Baekjoon]
published: false
tags:
  [algorithm, dijkstra, graph]
---
[배열 정렬(Gold 1)](https://www.acmicpc.net/problem/28707)

## Code

### 시간 초과
```cpp
#include <iostream>
#include <bits/stdc++.h>
#include <sstream>

using namespace std;

int N, M;

string VecToString(vector<int>& v)
{
    string s;
    
    for (auto ix : v)
    {
        s += '0' + ix;
        s += ' ';
    }

    return s;
}

void StringToVec(const string& s, vector<int>& v)
{
    v.clear();

    stringstream ss(s);
    int x;

    while (ss >> x)
    {
        v.push_back(x);
    }
}

bool Check(const vector<int>& v)
{
    if (v.size() == 0)
    {
        return true;
    }

    int Prev = v[0];

    for (int i = 1; i < v.size(); ++i)
    {
        if (Prev > v[i])
            return false;

        Prev = v[i];
    }

    return true;
}

struct cmp
{
    bool operator()(const pair<int, string>& Left, const pair<int, string>& Right)
    {
        return Left.first > Right.first;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int Answer = INT_MAX;

    cin >> N;

    vector<int> v(N);
    for (int i = 0; i < N; ++i)
    {
        cin >> v[i];
    }

    cin >> M;

    vector<vector<int>> Operation;
    for (int i = 0; i < M; ++i)
    {
        int l, r, c;
        cin >> l >> r >> c;

        Operation.push_back({ l-1,r-1,c });
    }

    priority_queue < pair<int, string>, vector<pair<int, string>>, cmp> pq;

    map<string, int> Dist;
    Dist[VecToString(v)] = 0;
    pq.push({ 0, VecToString(v) });

    while (!pq.empty())
    {
        string CurString = pq.top().second;
        vector<int> CurVec;
        StringToVec(CurString, CurVec);
        int CurDist = pq.top().first;
        pq.pop();

        if (Dist[CurString] < CurDist)
            continue;

        if (Check(CurVec))
        {
            Answer = min(Answer, CurDist);
            continue;
        }

        for (int i = 0; i < M; ++i)
        {
            int Left, Right, Cost;
            Left = Operation[i][0];
            Right = Operation[i][1];
            Cost = Operation[i][2];

            vector<int> NewVec = CurVec;
            swap(NewVec[Left], NewVec[Right]);
            int NewDist = CurDist + Cost;

            string NewString = VecToString(NewVec);

            if (Dist.find(NewString) == Dist.end())
            {
                Dist[NewString] = NewDist;
                pq.push({ NewDist,NewString });
                continue;
            }

            if (Dist[NewString] > NewDist)
            {
                Dist[NewString] = NewDist;
                pq.push({ NewDist,NewString });
            }
        }
    }

    if (Answer == INT_MAX)
    {
        cout << -1;
    }
    else
    {
        cout << Answer;
    }

    return 0;
}

```

### 정답

```cpp
#include <iostream>
#include <bits/stdc++.h>
#include <sstream>

using namespace std;

int N, M;

struct cmp
{
    bool operator()(const pair<int, vector<int>>& Left, const pair<int, vector<int>>& Right)
    {
        return Left.first > Right.first;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int Answer = -1;

    cin >> N;

    vector<int> v(N);
    for (int i = 0; i < N; ++i)
    {
        cin >> v[i];
    }

    vector<int> Sorted = v;
    sort(Sorted.begin(), Sorted.end());

    cin >> M;

    vector<vector<int>> Operation;
    for (int i = 0; i < M; ++i)
    {
        int l, r, c;
        cin >> l >> r >> c;

        Operation.push_back({ l-1,r-1,c });
    }

    priority_queue < pair<int, vector<int>>, vector<pair<int, vector<int>>>, cmp> pq;

    map<vector<int>, int> Dist;
    Dist[v] = 0;
    pq.push({ 0, v });

    while (!pq.empty())
    {
        vector<int> CurVec = pq.top().second;
        int CurDist = pq.top().first;
        pq.pop();

        if (Dist[CurVec] < CurDist)
            continue;

        if (CurVec == Sorted)
        {
            cout << CurDist;
            return 0;
        }

        for (int i = 0; i < M; ++i)
        {
            int Left, Right, Cost;
            Left = Operation[i][0];
            Right = Operation[i][1];
            Cost = Operation[i][2];

            vector<int> NewVec = CurVec;
            swap(NewVec[Left], NewVec[Right]);
            int NewDist = CurDist + Cost;


            if (Dist.find(NewVec) == Dist.end())
            {
                Dist[NewVec] = NewDist;
                pq.push({ NewDist,NewVec });
                continue;
            }

            if (Dist[NewVec] > NewDist)
            {
                Dist[NewVec] = NewDist;
                pq.push({ NewDist,NewVec });
            }
        }
    }

    cout << Answer;

    return 0;
}
```

## 문제 해석

주어진 문제는 다음과 같다.

- 길이 `N (≤ 8)`인 배열이 주어진다.
- `M`개의 연산이 주어지며, 각 연산은  
  `(l, r, c)` 형태로 **인덱스 `l`과 `r`을 swap할 수 있고 비용이 `c`** 든다.
- 이 연산들을 원하는 만큼 사용해서 배열을 **비내림차순(오름차순)** 으로 만들고자 한다.
- 그때의 **최소 비용**을 구하라.
- 만약 비내림차순으로 만들 수 없다면 `-1`을 출력한다.

핵심은 다음 두 가지다.

1. 단순히 정렬하는 문제가 아니라  
   **정해진 swap 연산만 사용 가능**하다.
2. 비용이 있으므로  
   **최소 비용으로 목표 상태에 도달해야 한다.**

---

## 문제 접근의 핵심 관찰

이 문제는 “정렬 방법을 만드는 문제”가 아니다.  
중요한 건 **어떤 과정으로 정렬되었는지**가 아니라,

**초기 배열 상태에서 정렬된 배열 상태로 도달하는 최소 비용**이다.

여기서 중요한 관찰이 하나 나온다.

- 배열의 크기 `N ≤ 8`
- 가능한 배열 상태 수는 최대 `8! = 40320`

즉, **모든 배열 상태를 노드로 보고 탐색해도 충분히 가능**하다.

---

## 상태 전이 그래프로의 해석

이 문제는 다음과 같이 해석할 수 있다.

- 하나의 **배열 상태** = 하나의 **노드**
- 하나의 **swap 연산** = 상태에서 상태로 이동하는 **간선**
- 간선의 가중치 = 해당 swap의 비용
- 시작 노드 = 입력으로 주어진 배열
- 목표 노드 = 배열을 오름차순으로 정렬한 상태

이렇게 보면 문제는 곧 다음과 같다.

> **시작 상태에서 목표 상태까지  
> 최소 비용으로 이동하는 경로를 찾아라**

즉, **다익스트라(Dijkstra)** 를 적용할 수 있는 전형적인 최단경로 문제다.

---

## 알고리즘 설계 (다익스트라)

### 상태 정의
- 상태: `vector<int>` (현재 배열 상태)
- 거리: 해당 상태까지 도달하는 최소 비용

### 자료구조
- `priority_queue`  
  - `(현재까지 비용, 현재 상태)` 형태
  - 비용 기준 최소 힙
- `dist`  
  - `map<vector<int>, int>`  
  - 각 상태의 최소 비용 기록

### 탐색 과정
1. 초기 배열을 PQ에 넣고 거리 0으로 시작
2. PQ에서 비용이 가장 작은 상태를 꺼냄
3. 이미 더 작은 비용으로 방문한 상태면 skip
4. 현재 상태가 정렬된 상태라면 그 비용이 정답
5. 모든 swap 연산을 적용해 다음 상태들을 만들고
   - 기존보다 비용이 작으면 갱신 후 PQ에 push

다익스트라의 특성상 **정렬된 상태가 처음 PQ에서 pop되는 순간**의 비용이
곧 최소 비용이므로 즉시 종료해도 된다.

---

## 구현 시 핵심 포인트

1. 상태 비교
정렬 여부는 단순히

```cpp
  if (CurVec == Sorted)
```

로 판단한다.
별도의 검사 함수보다 빠르고 명확하다.

2. 상태 저장 방식
처음에는 문자열 인코딩을 고려할 수 있지만,
이 문제에서는 다음 이유로 vector<int> 자체를 상태로 써도 충분하다.

- 배열 크기 최대 8
- 상태 수 최대 약 4만
- 메모리 제한에 충분히 여유 있음
- 문자열 변환 비용을 제거할 수 있음

3. 다익스트라 종료 조건
```cpp
  if (CurVec == Sorted) {
      cout << CurDist;
      return 0;
  }
```
다익스트라의 성질상, 이 순간의 CurDist가 최소 비용이다.

시간 복잡도
- 상태 수: 최대 8! ≈ 40320
- 각 상태에서 최대 M개의 연산 적용
- 전체 시간 복잡도는 대략
  O(상태 수 × M × log 상태 수)

문제 조건에서는 충분히 통과 가능한 수준이다.

## 왜 이 문제를 못 풀었는지에 대한 회고

이 문제를 왜 못 풀었는지 곰곰이 생각해봤다.

가장 처음 막혔던 지점은 **“비내림차순으로 정렬한다”는 조건 자체를 해석하는 방식**이었던 것 같다.  
지금까지 풀어온 정렬 문제들은 대부분 “배열을 오름차순/내림차순으로 정렬하라”였고, 그때는 정렬 알고리즘이 이미 답이거나, 정렬 결과를 이용해 다른 처리를 하는 문제들이었다.

그런데 이 문제는 달랐다.  
**바꿀 수 있는 위치가 제한되어 있고, 그 연산을 이용해서 비내림차순을 만들어야 하며, 비용까지 최소화해야 한다.**  
이 조건을 보는 순간, 나는 자연스럽게 “그리디하게 정렬을 만들어가는 방법”을 떠올렸다.

그래서 처음엔 이런 식으로 생각했다.  
정렬된 배열을 기준으로 앞에서부터 보면서, 각 자리마다 “이 자리에 와야 하는 값”을 현재 위치에서 가져오는 최소 비용을 계산하면 되지 않을까?

하지만 조금만 생각해보니 이 방식은 문제가 많았다.

- 앞에서 자리를 맞추는 과정이 항상 전체 최소 비용을 보장하지 않는다는 점
- swap 한 번이 여러 위치를 동시에 바꿔버린다는 점
- 중복된 숫자가 있을 경우 어떤 값을 어느 자리로 가져와야 하는지 애매해진다는 점

이 지점에서 “이 문제는 그리디로는 깔끔하게 풀리지 않겠다”는 감은 왔지만,  
그 다음 단계로 **완전 탐색**을 떠올리지는 못했다.

지금 생각해보면, 여기서 이미 한 번 스스로를 제한하고 있었던 것 같다.  
“이건 분명 완전 탐색 문제가 아닐 거야”라고 근거 없이 단정해버렸고,  
그래서 더 빠르고 우아한 해법만을 계속 찾고 있었다.

---

## 다익스트라를 ‘그래프’로만 생각했던 한계

전환점은 “상태 자체를 노드로 보고 다익스트라를 적용할 수 있다”는 힌트를 들었을 때였다.

나는 다익스트라를 항상 **그래프 문제**로만 생각해왔다.  
정점이 명확히 존재하고, 간선이 주어져 있으며,  
상태는 `{현재 노드, 현재 거리}`처럼 단순한 형태라고 인식하고 있었다.

그런데 이 문제에서는

- 하나의 배열 상태가 하나의 노드가 되고
- swap 연산이 상태에서 상태로 이동하는 간선이 되며
- 목표는 “정렬된 배열 상태에 도달하는 최소 비용”

이라는 식으로 **상태 전이 그래프**로 해석할 수 있었다.

이런 형태의 다익스트라는 사실 처음 접하는 유형이었고,  
그래서 “상태를 어떻게 저장하지?”라는 부분에서 가장 크게 막혔다.

---

## 상태 표현에서의 잘못된 판단

처음에는 상태를 그대로 저장하는 게 부담스럽게 느껴졌다.  
`vector<int>`를 상태로 쓰면 노드마다 복사되고,  
PQ와 dist 테이블에 전부 저장되니 메모리를 너무 낭비하는 게 아닐까?라는 생각이 들었다.

그래서 타협안으로 선택한 게  
`vector<int> → string`으로 인코딩해서 상태를 저장하는 방식이었다.

풀면서도 사실 찜찜하긴 했다.

- PQ에서 하나를 pop할 때마다 `string → vector`
- 연산 하나를 적용할 때마다 `vector → string`

이 변환이 계속 반복되는데, 이게 과연 괜찮을까?라는 의문이 계속 들었다.

결과는 예상대로 시간 초과였다.

---

## 문제 크기를 제대로 봤다면 했을 선택

마지막 힌트를 통해 깨달은 건,  
**이 문제에서는 내가 걱정하던 것들이 실제로는 문제 되지 않는 규모**라는 점이었다.

- 배열 크기는 최대 8
- 상태 수는 최대 `8! ≈ 40320`
- `vector<int>` 하나의 원소 데이터는 32바이트 수준
- PQ와 map에 중복 저장이 있더라도 전체 메모리는 충분히 감당 가능

이걸 숫자로 확인하고 나서야  
“굳이 string으로 인코딩할 필요가 없구나”라는 판단이 섰고,  
상태를 `vector<int>` 그대로 다익스트라에 넣었더니 문제는 바로 풀렸다.

---

## 정리: 내가 놓쳤던 핵심들

정리해보면, 내가 이 문제를 못 풀었던 이유는 명확했다.

1. **다익스트라는 그래프에서만 쓰는 알고리즘이라고 제한적으로 생각했다.**  
   상태 전이 문제에서도 “상태 = 노드”로 보고 최단거리를 구할 수 있다는 관점을 몰랐다.

2. **완전 탐색 가능성을 초기에 배제했다.**  
   “이건 분명 완전 탐색이 아닐 거야”라고 감으로 단정했고,  
   상태 수를 실제로 계산해보지 않았다.

3. **근거 없이 불가능하다고 판단했다.**  
   `vector`를 상태로 쓰면 메모리가 너무 크지 않을까,  
   성능이 안 나오지 않을까라는 생각을 했지만,  
   실제 크기와 연산량을 계산해보지는 않았다.

---

## 이번 문제를 통해 얻은 교훈

> 문제를 보자마자 “이건 안 될 것 같다”라고 판단하지 말고,  
> **상태 수와 연산량을 먼저 계산해보고, 완전 탐색 가능성부터 검증하자.**

이 관점 하나만 빨리 떠올렸어도, 훨씬 수월하게 풀 수 있었을 문제였다.
