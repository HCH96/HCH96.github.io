---
title: 가장 긴 증가하는 부분 수열 5
date: 2025-12-26 18:00:00 +09:00
categories: [Algorithm, Baekjoon]
published: false
tags:
  [algorithm, lis]
---

[가장 긴 증가하는 부분 수열 5](https://www.acmicpc.net/problem/14003)

### Code

```cpp
#include <iostream>
#include <bits/stdc++.h>
#include <sstream>

using namespace std;

int N;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> N;

    vector<int> Arr(N);

    for (int i = 0; i < N; ++i)
    {
        cin >> Arr[i];
    }
  
    vector<int> Tail;
    vector<int> TailIdx;
    vector<int> Parent;

    for (int i = 0; i < N; ++i)
    {
        int Cur = Arr[i];

        int Idx = lower_bound(Tail.begin(), Tail.end(), Cur) - Tail.begin();

        if (Idx == Tail.size())
        {
            Tail.push_back(Cur);
            TailIdx.push_back(i);
        }
        else
        {
            Tail[Idx] = Cur;
            TailIdx[Idx] = i;
        }

        if (Idx == 0)
        {
            Parent.push_back(-1);
        }
        else
        {
            Parent.push_back(TailIdx[Idx-1]);
        }

    }

    deque<int> Answer;

    int CurIdx = TailIdx[TailIdx.size() - 1];

    while (CurIdx != -1)
    {
        Answer.push_front(Arr[CurIdx]);
        CurIdx = Parent[CurIdx];
    }
    
    cout << Answer.size() << "\n";

    for (int i = 0; i < Answer.size(); ++i)
    {
        cout << Answer[i] << " ";
    }



    return 0;
}
```

## 문제 해석

수열이 주어졌을 때 **가장 긴 증가하는 부분 수열(LIS)** 을 구하는 문제이다.

- 부분 수열은 연속할 필요는 없지만
- **원래 인덱스 순서**를 유지해야 하며
- **엄격히 증가**해야 한다.

이 문제는 다음 두 가지를 동시에 요구한다.

1. LIS의 길이  
2. LIS 수열 자체 출력  

입력 크기가 매우 크기 때문에 단순한 `O(N²)` DP 방식은 사용할 수 없으며, **`O(N log N)` 알고리즘과 수열 복원이 가능한 구조**가 필요하다.

---

## 문제 접근 

### 1. 치환 LIS

가장 먼저 고려한 방법은 이분 탐색을 이용한 **치환 방식 LIS (`O(N log N)`)** 이다.

- `tail` 배열을 유지
- 현재 값이 들어갈 위치를 이분 탐색으로 탐색
- 값이 크면 뒤에 추가
- 작으면 해당 위치를 치환

하지만 다음과 같은 이유로  
이 방식만으로는 부족하다고 판단했다.

- `tail` 배열은 실제 LIS 수열을 의미하지 않음
- 치환 과정에서 실제로 존재하지 않는 수열 조합이 만들어질 수 있음
- 따라서 **LIS의 길이는 구할 수 있으나, 수열 복원은 불가능**하다고 판단

이 단계에서는 치환 LIS를  
**길이 계산 전용 알고리즘**으로만 인식하고 있었다.

---

### 2. 스택을 이용한 LIS 구성 시도

다음으로 고려한 방법은 **스택 하나로 LIS를 직접 구성하는 방식**이다.

- 스택 top보다 현재 값이 크면 push
- 작으면 더 작은 값이 나올 때까지 pop 후 삽입

하지만 이 방식에는 구조적인 문제가 존재한다.

- 스택 하나에 LIS를 확정하는 구조
- 현재 시점에서는 불리해 보이는 값이 이후 LIS 구성에 반드시 필요한 경우가 존재
- 인덱스 순서를 고려하면 값 기준 pop은 논리적 오류를 발생시킴

반례가 쉽게 구성되므로 이 접근은 **LIS의 최장 길이를 보장할 수 없다고 판단하여 제외**했다.

---

###  D3. DP 기반 LIS + 추적

다음으로 고려한 방법은 전형적인 DP 풀이이다.

- `dp[i]` : i번째 원소를 마지막으로 하는 LIS의 최대 길이

점화식은 다음과 같다.
```text
dp[i] = max(dp[j] + 1) if (j < i, Arr[j] < Arr[i])
```

이 방식은 논리적으로 문제가 없으며, 추적 또한 `dp` 값이 감소하는 방향으로 충분히 가능하다.

그러나 입력 크기(`N ≤ 1,000,000`)를 고려하면 시간 복잡도 `O(N²)`로 인해 제한 시간 내 실행이 불가능하다.

---

### 4. 치환 LIS + 추적 정보 저장

이 문제는 입력 크기 제약으로 인해 **`O(N log N)` 시간 복잡도의 LIS 알고리즘을 사용해야 한다.**

이에 따라, 이분 탐색 기반의 **치환 LIS**에 수열 복원을 위한 **추적 정보**를 추가하는 방식으로 접근했다.

치환 LIS에서 중요한 성질은 다음과 같다.

- `tail[k]` 자리에 숫자가 들어간다는 것은
- **길이 `k+1`인 증가 부분수열이 실제로 하나 이상 존재한다는 의미**이다.

즉, 해당 숫자가 `tail[k]`에 들어가는 순간 그 숫자 앞에 올 수 있는 원소 또한 **이미 확정된 상태**이다.

이 연결 관계를 저장하면 이후 수열을 역추적하는 것이 가능하다.

예를 들어, 현재까지 처리한 결과가 tail = [0, 3, 5] 일 때,

- 길이 1의 증가 부분수열의 끝값 후보 중 최소값은 `0`
- 길이 2의 증가 부분수열의 끝값 후보 중 최소값은 `3`
- 길이 3의 증가 부분수열의 끝값 후보 중 최소값은 `5`

이 상태에서 새로운 값 `2`가 들어온 경우를 생각해보면,

- `2`는 `tail[1] = 3` 자리에 치환된다.
- 이 치환은 단순한 값 변경이 아니라, **길이 2의 증가 부분수열이 실제로 성립함을 의미**한다.

즉, 이 순간에는 0 → 2와 같은 증가 부분수열이 실제로 존재한다.

이때 중요한 점은,`2`가 `tail[1]`에 들어갔다는 사실만으로도 **`2` 앞에 오는 원소(`0`)는 이미 확정된 상태**라는 것이다.

따라서 이 연결 관계를 저장해 두면, 나중에 더 큰 값들이 이어붙여질 경우 실제로 성립했던 증가 부분수열을 그대로 역추적할 수 있다.

이와 같은 원리로, 치환이 일어나는 순간마다 해당 숫자와 그 앞 원소의 연결 관계를 저장하면 치환 여부와 상관없이 **실제로 존재하는 LIS 경로를 복원할 수 있다.**

이 성질을 기반으로 **치환 + 추적이 가능한 LIS 구조**를 설계했다.

---

## 사용한 자료구조와 의미

### `tail`

- 길이별 증가 부분수열 후보 중 **끝값의 최소값**
- 항상 오름차순을 유지하여 이분 탐색 가능
- 실제 LIS 수열을 의미하지는 않음

### `tailIdx`

- `tail` 배열을 구성한 **실제 원소의 인덱스**
- LIS 복원 시 시작 인덱스를 결정하는 데 사용

### `parent`

- 어떤 원소가 `tail`에 추가되거나 치환될 때
- **그 바로 앞에 실제로 연결되었던 원소의 인덱스**
- 추상적인 가능성이 아닌, **실제로 성립한 수열의 연결 기록**

---

## 치환 + 추적의 핵심 원리

- 치환은 단순히 값을 덮어쓰는 행위가 아니다.
- 해당 숫자가 들어가는 순간, **그 길이의 증가 부분수열이 실제로 성립**한다.
- 따라서
  - 현재 숫자가 `tail[pos]`에 들어간 경우
  - `tailIdx[pos - 1]`은 반드시 앞에 올 수 있는 원소가 된다.
- 이 인덱스를 `parent`에 저장하면
  이후 **실제 LIS 경로를 그대로 복원**할 수 있다.

---

## 추적 시작점 선택

모든 원소를 처리한 뒤,

- `tail`의 길이는 LIS의 길이를 의미하고
- `tail`의 마지막 원소(`tailIdx[last]`)는
  - 해당 길이를 만드는 증가 부분수열 중 하나의 끝 원소이며
  - 실제로 존재하는 LIS의 마지막 원소로 사용 가능하다.

따라서 이 인덱스를 시작점으로 하여  
`parent`를 따라가면 **유효한 LIS 하나를 복원할 수 있다.**