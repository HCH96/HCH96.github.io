---
title: 제한적 직접 실행 원리
date: 2024-11-20 18:05:00 +09:00
categories: [OS, Virtualization]
tags:
  [operating system, ostep]
---

## **CPU 가상화와 운영체제의 과제**

운영체제는 **CPU 시간을 나누어 사용하는 방식**으로 CPU 가상화를 구현한다. 이를 통해 여러 프로세스가 마치 독립적으로 CPU를 사용하는 것처럼 보이게 만든다. 그러나 이러한 가상화 기법을 구현하기 위해 몇 가지 문제를 해결해야 한다.

1. **성능 저하 문제**
가상화를 구현하기 위해서는 운영체제가 CPU의 동작을 세밀하게 관리해야 한다. 하지만 이 과정에서 **시스템 오버헤드**가 발생할 수 있으며, 이는 전체 시스템의 성능 저하를 초래할 가능성이 있다. 따라서 운영체제는 **오버헤드를 최소화**하면서 가상화를 구현해야 한다.

2. **제어 문제**
운영체제는 CPU의 **제어권(control)**을 유지하면서 여러 프로세스를 효율적으로 실행시켜야 한다.

## **제한적 직접 실행(Limited Direct Execution)**

### **직접 실행**
> 프로그램을 빠르게 실행하기 위해, 프로그램을 **CPU 상에서 직접 실행**시키는 방식이 사용될 수 있다.  

운영체제는 프로그램 실행 시 다음과 같은 작업을 수행한다.
1. **프로세스 목록에 항목 추가**  
   실행할 프로그램을 관리하기 위해 **프로세스 테이블**에 해당 프로세스의 정보를 추가한다.

2. **메모리 할당**  
   프로그램의 실행을 위해 필요한 메모리를 할당한다.

3. **프로그램 코드 로드**  
   프로그램의 코드를 디스크에서 읽어 메모리에 로드한다.

4. **진입점(branch point) 탐색**  
   프로그램 실행을 시작할 진입점을 찾아 CPU가 해당 지점에서 코드를 실행하도록 분기한다.


![alt text](/assets/img/OS/Limited%20Direct%20Execution/image.png)
_직접 실행 프로토콜_

#### **직접 실행의 문제점**

1. **운영체제의 제어권 상실**
- 프로그램이 직접 실행되면, **운영체제가 제어권을 유지하기 어려워진다**.
- 프로그램이 운영체제가 원하지 않는 작업(예: 시스템 자원 손상, 디스크 입출력 요청)을 수행할 수 있다.

2. **프로세스 전환 불가**
- 직접 실행 중인 프로그램을 운영체제가 중단하거나 다른 프로세스로 전환하기 어렵다.
- CPU 가상화에 필요한 시분할 기법을 구현하기 어려워진다.


#### **제한된 연산**

프로세스가 I/O 요청이나 메모리 추가 할당과 같은 연산을 직접 수행할 경우, 시스템 안정성이 위협받을 수 있다. 이를 방지하기 위해 운영체제는 이러한 연산을 제한하고, 해당 작업을 수행할 수 있도록 시스템 콜을 제공하여 제어권을 유지한다.


### **보호된 제어 양도**
하드웨어는 두 가지 실행 모드를 제공하여 운영체제의 보호를 돕는다.

1. 사용자 모드 (User Mode): 일부 명령어는 사용이 제한되는 모드
2. 커널 모드 (Kernel Mode): 모든 특수한 명령어를 포함하는 원하는 모든 작업을 수행할 수 있는 모드

운영체제는 트랩 (trap) 명령어를 사용하여 사용자 모드에서 커널 모드로 전환하며, return-from-trap 명령어로 다시 사용자 모드로 돌아갈 수 있다. 또한, 하드웨어는 트랩 테이블의 메모리 주소를 운영체제에 전달하는 명령어를 사용하여 효율적인 모드 전환을 지원한다.

운영체제는 프로세스가 제한된 연산을 요청할 수 있도록 시스템 콜을 지원한다. 
- trap
    - 사용자 모드에서 실행 중인 프로세스가 운영체제의 커널 모드로 진입하기 위해 사용하는 명령어
    - 프로세스가 시스템 콜을 요청하거나 하드웨어 예외가 발생할 때 사용되며, 커널 모드로의 전환을 통해 운영체제가 직접 자원을 관리할 수 있도록 한다.
- return-from-trap
    - 커널 모드에서 사용자 모드로 돌아가기 위해 사용하는 명령어
    - 시스템 콜을 처리한 후, 운영체제는 이 명령어를 사용하여 제어를 사용자 프로세스에 반환하고, 다시 사용자 모드에서 실행을 계속하도록 한다.

#### **trap 명령어의 과정**

1. **프로세스가 trap 명령어를 수행**
   - 사용자 모드에서 실행 중인 프로세스가 시스템 콜을 요청하거나 하드웨어 예외가 발생하면 **trap 명령어**가 실행된다.
   - 이를 통해 프로세스는 커널 모드로 전환된다.

2. **프로세스 상태 저장**
   - 운영체제는 커널 모드로 전환하기 전, 프로세스의 중요한 상태(프로그램 카운터, 플래그, 기타 레지스터)를 **커널 스택**에 저장한다.
   - 이 정보는 나중에 사용자 모드로 복귀할 때 사용된다.

3. **커널 모드에서 작업 수행**
   - 운영체제는 커널 모드에서 시스템 콜 처리나 예외 처리와 같은 작업을 수행한다.

4. **return-from-trap 명령어 실행**
   - 커널 모드에서 작업을 마친 후, **return-from-trap** 명령어가 실행된다.
   - 이 명령어는 커널 스택에 저장된 프로세스의 상태 정보를 꺼내어(pop) 사용자 모드로 복귀한다.

5. **사용자 모드로 복귀**
   - 프로세스는 **사용자 모드**로 돌아가며, 중단되었던 지점에서 실행을 계속 시작한다.

- trap table
    - 시스템 콜이나 하드웨어 예외에 대해 각각의 트랩 번호에 대응하는 핸들러(함수)의 주소를 저장한다.

- trap handler
    - 시스템 콜이나 하드웨어 예외가 발생했을 때, 운영체제가 실행하는 함수이다. 트랩 핸들러는 트랩 번호에 해당하는 작업을 수행하며, 요청된 작업을 처리한 후, 결과를 프로세스에 반환하거나 에러 메시지를 보낸다.

![alt text](/assets/img/OS/Limited%20Direct%20Execution/image-1.png)
_제한적 직접 실행 프로토콜_

1. 윈도우 부팅시 운영체제는 트랩테이블을 초기화하고 하드웨어(CPU)는 핸들러 주소를 기억한다.
2. 운영체제는 커널 모드에서 프로그램을 실행할 준비를 마치고 return-from-trap을 수행한다.
3. 하드웨어는 커널 스택으로부터 레지스터를 복원하고 사용자 모드로 이동하여 프로그램의 main을 실행한다.
4. 프로세스가 시스템 콜을 호출하여 운영체제로 트랩한다.
5. cpu는 레지스터를 커널 스택에 저장하고(return시에 돌아오기 위해) 커널모드로 이동, 트랩 핸들러로 pc를 분기한다.(부팅시 저장되어 있던 핸들러의 주소를 이용한다)
6. 트랩을 처리한다.(트랩 테이블에 매핑되어 있는 올바른 트랩 핸들러 함수를 실행)
7. 시스템 콜의 임무를 수행한다.
8. 리턴시 cpu는 커널 스택으로부터 레지스터를 복원하여 사용자 모드로 이동하여 원래의 위치로 pc를 분기한다.

### **프로세스 간 전환**

운영체제가 실행 중인 프로세스로부터 CPU의 제어권을 가져와 다른 프로세스에게 넘기는 과정은 **프로세스 간 전환**이라고 한다. 하지만 프로세스가 실행 중일 때는 운영체제가 실행되지 않기 때문에, 운영체제가 직접적으로 CPU 제어권을 회수할 수 없다.  

이 문제를 해결하기 위해 **타이머 인터럽트**를 사용한다. 타이머 인터럽트는 **타이머 장치**가 주기적으로(수 밀리 초마다) 인터럽트를 발생시키도록 설정하는 것이다.  

운영체제는 하드웨어에게 타이머 인터럽트가 발생했을때 실행해야 할 코드를 알려주어야 한다. 부팅될 때 운영체제가 이런 준비를 한다.

#### **타이머 인터럽트의 동작 과정**
1. **인터럽트 발생**  
   - 타이머가 설정된 주기에 따라 인터럽트를 발생시킨다.
   - 인터럽트가 발생하면 현재 실행 중인 프로세스는 중단되고, 운영체제의 **인터럽트 핸들러(interrupt handler)**가 실행된다.

2. **운영체제의 CPU 제어권 획득**  
   - 인터럽트 핸들러가 실행되면서 운영체제는 CPU의 제어권을 다시 얻게 된다.
   - 이 시점부터 운영체제는 필요한 작업(예: 다른 프로세스로 전환)을 수행할 수 있다.

3. **타이머 설정 및 부팅 과정**  
   - 운영체제는 부팅 과정 중에 하드웨어에 타이머 인터럽트 발생 시 실행할 핸들러를 설정한다.
   - 또한, 운영체제는 타이머 장치를 시작하거나 특정 명령어를 통해 타이머를 종료할 수 있다.

#### **프로세스 상태 저장 및 복원**
- 인터럽트가 발생하면 하드웨어는 실행 중이던 프로그램의 상태(프로그램 카운터, 레지스터 값 등)를 저장한다.
- 이렇게 저장된 정보는 **return-from-trap** 명령어를 통해 프로그램을 다시 실행할 때 사용된다.
- 이를 통해 중단되었던 프로세스는 중단된 시점부터 다시 실행을 이어갈 수 있다.

#### **문맥의 저장과 복원**

운영체제가 타이머 인터럽트나 하드웨어 인터럽트를 통해 CPU 제어권을 회수한 후, 실행 중이던 프로세스를 계속 실행할 것인지, 아니면 다른 프로세스로 전환할 것인지 결정해야 한다. 이 결정은 운영체제의 **스케줄러(scheduler)**가 담당한다. 스케줄러는 시스템 자원과 우선순위를 고려하여 어떤 프로세스를 실행할지 결정한다.

#### **문맥 교환(Context Switch)**
운영체제가 한 프로세스에서 다른 프로세스로 전환하기로 결정하면 **문맥 교환**이 발생한다.  
문맥 교환은 다음과 같은 과정으로 이루어진다:

1. **현재 프로세스의 상태 저장**  
   - 실행 중이던 프로세스의 **레지스터 값**과 **프로그램 카운터(PC)**를 해당 프로세스의 **커널 스택(kernel stack)**에 저장한다.  
   - 이렇게 저장된 정보는 해당 프로세스를 다시 실행할 때 사용된다.

2. **새로운 프로세스 상태 복원**  
   - 스케줄러가 다음에 실행할 프로세스를 선택하면, 해당 프로세스의 커널 스택에서 **레지스터 값**과 **PC**를 복원한다.  
   - 이 과정을 통해 새롭게 선택된 프로세스가 이전에 중단된 상태에서부터 실행을 이어갈 수 있다.

3. **프로세스 실행 재개**  
   - 운영체제는 **return-from-trap** 명령어를 사용하여 CPU를 새 프로세스에 넘긴다.  
   - 이를 통해 새로운 프로세스가 사용자 모드에서 실행을 시작한다.

#### **문맥 교환의 중요성**
문맥 교환은 프로세스 간 전환을 가능하게 하는 핵심 메커니즘이다.  
운영체제는 현재 실행 중인 프로세스의 **변수, 레지스터 값, PC**뿐만 아니라 **커널 스택 포인터**까지 저장하여 다음 실행 시 정확히 복원한다.  
이를 통해 각 프로세스는 자신의 작업을 중단된 상태에서 이어갈 수 있으며, 운영체제는 여러 프로세스를 효율적으로 관리할 수 있다.

![alt text](/assets/img/OS/Limited%20Direct%20Execution/image-2.png)
_제한적 직접 실행 프로토콜(타이머 입터럽트)_

> 시스템 콜을 처리하는 도중에 타이머 인터럽트가 발생하지 않도록 인터럽트를 불능화 시킨다.
{: .prompt-info }

