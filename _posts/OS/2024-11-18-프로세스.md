---
title: 프로세스
date: 2024-11-18 17:00:00 +09:00
categories: [OS, Virtualization]
tags:
  [operating system, ostep, process]
---

## 프로세스와 프로그램의 차이
- 프로그램 : 디스크에 저장된 실행 가능한 명령어와 정적 데이터의 묶음. 실행되기 전의 상태로 정적인 개념.
- 프로세스 : 실행 중인 프로그램. 운영체제가 자원을 할당하여 동작하게 만든 동적인 개념.

## 프로세스의 구성 요소

### 코드 영역(Code Section)

- 실행할 프로그램의 명령어들이 저장된 영역.
- 일반적으로 실행 파일로부터 로드되어 메모리에 적재됨.

### 데이터 영역(Data Section)

- 초기화된 전역 변수와 정적 변수가 저장된 영역.
- 프로그램 실행 중에도 접근 가능하며, 수정될 수 있음.

### 힙(Heap)

- 실행 중 동적으로 할당되는 메모리 공간.
- 런타임 중 생성되는 객체나 동적 변수들이 저장됨.
- 크기가 변할 수 있어 관리가 필요함(메모리 누수 방지 등).

### 스택(Stack)

- 함수 호출 시 생성되는 지역 변수와 함수의 리턴 주소 등이 저장되는 공간.
- 함수 호출 시 쌓이고(pop) 종료 시 제거(push)되는 LIFO 구조.

### 레지스터(Registers)

- CPU가 처리 중인 명령어나 데이터를 저장하는 고속 메모리.

- 주요 레지스터:
    - 프로그램 카운터(Program Counter, PC): 현재 실행 중인 명령어의 주소를 저장.
    - 스택 포인터(Stack Pointer, SP): 스택의 최상위 주소를 가리킴.
    - 프레임 포인터(Frame Pointer, FP): 현재 함수 호출의 시작 주소를 가리킴.

### 프로세스 제어 블록(Process Control Block, PCB)

- 운영체제가 프로세스를 관리하기 위해 사용하는 자료구조.
- 포함된 정보:
    - 프로세스 상태 (실행 중, 대기 중 등)
    - 프로세스 ID (PID)
    - CPU 레지스터 상태
    - 메모리 관리 정보
    - 입출력 상태 등

## 시분할 기법

운영체제는 CPU를 하나의 프로세스에만 독점적으로 할당하지 않고, 정해진 시간 단위(time slice) 동안 여러 프로세스에 순차적으로 CPU를 할당하는 방식으로 동작한다. 이 방식을 시분할(Time Sharing) 기법이라고 한다.

시분할 기법에서는 각 프로세스가 일정 시간 동안 CPU를 사용한 후, 운영체제가 강제로 CPU를 회수하여 다른 프로세스에 할당한다. 이를 통해 여러 프로세스가 동시에 실행되는 것처럼 보이도록 CPU를 가상화한다.

CPU가 여러 프로세스 사이에서 공유되기 때문에, 각 프로세스가 단독으로 CPU를 사용할 때와 비교하면 개별 프로세스의 성능은 다소 낮아질 수 있다. 그러나 이러한 방식은 사용자에게 공정하고 신속한 작업 응답을 제공하며, 시스템 자원의 활용도를 극대화할 수 있다.


## 프로세스 API
- 생성 ( Create ) 
    - 새로운 프로세스를 생성하는 기능을 제공하는 API.
    - 부모 프로세스가 자식 프로세스를 생성하거나, 프로그램을 실행하는 시스템 호출.
    - fork(), exec()
- 제거 ( Delete )
    - 실행 중인 프로세스를 종료하거나 강제로 제거할 수 있는 기능을 제공.
    - 프로세스가 정상적으로 종료되거나, 시스템에 의해 강제 종료될 때 사용.
    - exit(), kill()
- 대기 ( Wait ) 
    - 특정 프로세스의 실행이 완료되기를 기다리는 API.
    - 부모 프로세스가 자식 프로세스의 종료를 기다릴 때 자주 사용됨.
    - wait(), waitpid()
- 각종 제어 ( Miscellaneous Control ) 
    - 프로세스의 동작을 제어하는 다양한 기능 제공.
        - 프로세스 일시 정지 (suspend)
        - 프로세스 재개 (resume)
- 상태 ( Status )
    - 프로세스의 상태 정보를 얻는 기능 제공.
    - 프로세스의 실행 상태, 메모리 사용량, CPU 점유율 등의 정보를 조회.
    - getpid(), getppid()

## 프로세스의 생성
: 운영체제가 새로운 프로그램을 실행할 준비를 하는 과정

1. **프로그램 코드와 정적 데이터(static data)의 메모리 로드**

   - 실행 파일의 **코드(명령어)**와 **정적 데이터(초기화된 전역 변수 등)**를 프로세스의 주소 공간에 적재한다.  
   - 운영체제의 로더(loader)가 수행하며, 코드 영역과 데이터 영역으로 나누어 메모리에 배치된다.

2. **스택과 힙 생성 및 초기화**

   - **스택(Stack)**: 함수 호출 시 필요한 지역 변수와 리턴 주소를 저장하기 위해 생성된다.  
   - **힙(Heap)**: 실행 중 동적으로 할당되는 메모리를 관리하기 위해 생성된다.  
   - 스택과 힙은 프로세스의 주소 공간에서 서로 반대 방향으로 확장되도록 초기화된다.

3. **입출력 설정 및 초기화**

   - 표준 입출력(standard I/O)과 관련된 기본 설정을 수행한다.  
     - 예: 표준 입력(stdin), 표준 출력(stdout), 표준 에러(stderr) 등을 초기화.  
   - 프로세스 실행에 필요한 파일 디스크립터를 설정하거나, 입출력 장치와의 연결을 구성한다.

4. **프로그램의 시작 지점(entry point)에서 실행 시작**

   - 프로그램의 진입점(예: `main()` 함수)을 지정하고, 해당 위치에서부터 명령어를 실행한다.  
   - **프로그램 카운터(Program Counter)**가 진입점을 가리키며, 실행이 시작된다.

## 프로세스 상태

1. **실행 (Running)**  
   - 현재 CPU를 점유하고 명령어를 실행 중인 상태.  
   - 프로세스는 실행 상태에서만 실제 작업을 수행한다.

2. **준비 (Ready)**  
   - 실행할 준비가 되어 있는 상태로, CPU 할당을 기다린다.  
   - 실행 상태로 전환될 수 있는 대기 상태이며, 대기 큐(Ready Queue)에 들어가 있다.

3. **대기 (Blocked)**  
   - 프로세스가 특정 사건(예: I/O 완료, 자원 할당)을 기다리는 상태.  
   - 다른 사건이 완료될 때까지 CPU를 사용하지 못하며, 대기 큐가 아닌 별도의 I/O 또는 이벤트 대기 큐에 들어가 있다.

![alt text](/assets/img/OS/process/image.png)
_프로세스의 상태는 운영체제의 정책에 따라 전이된다_

