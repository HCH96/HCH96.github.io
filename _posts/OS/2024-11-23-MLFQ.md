---
title: 멀티 레벨 피드백 큐(Multi-level Feedback Queue, MLFQ)
date: 2024-11-23 02:00:00 +09:00
categories: [OS, Virtualization]
tags:
  [operating system, ostep,scheduling, MLFQ]
---

## MLFQ의 목적

1. 짧은 작업의 우선 실행
    - 짧은 작업(Short jobs)을 먼저 실행하여 반환 시간(Turnaround time) 을 최소화한다.
2. 대화형 사용자 지원
    - 화면 앞에서 작업의 종료를 기다리는 대화형 사용자(Interactive users) 에게 빠른 응답을 제공하여 응답 시간(Response time) 을 최적화한다.

> 기존의 SJF(Shortest Job First)나 STCF(Shortest Time to Completion First) 같은 알고리즘은 작업의 실행 시간(Execution time) 을 알아야 하지만, 현실에서는 작업의 실행 시간을 미리 정확히 예측하는 것이 불가능하다. MLFQ는 이런 한계를 극복하기 위해 실행 중인 작업의 행동 특성을 관찰하고,
이를 바탕으로 작업의 특성을 추정하여 동적으로 스케줄링에 반영한다.
{: .prompt-info }

---

## MLFQ의 기본 규칙
- MLFQ는 여러 개의 **큐(Queue)** 로 구성되며, 각각 다른 **우선순위(priority level)** 를 가진다.  작업이 실행 준비 상태(Ready state)에 들어가면 반드시 이 중 하나의 큐에 배정된다. 
- 큐의 둘 이상의 작업이 존재할 경우 모두 같은 우선순위를 가진다. 이 작업들 사이에서는 **라운드 로빈** 스케줄링 알고리즘이 사용된다.
- MLFQ는 각 작업에 고정된 우선순위를 부여하는 것이 아니라 각 작업의 특성에 따라 동적으로 우선순위를 부여한다. 
  - 키보드 입력을 기다리며 반복적으로 CPU를 양보하는 작업은 **우선순위를 높게 유지**한다.
  - 긴 시간 동안 CPU를 집중적으로 사용하는 작업은 **우선순위가 낮아진다**.

### **우선순위 변경이 필요한 이유**
![alt text](/assets/img/OS/MLFQ/image.png){: style="width: 70%; display: block; margin: 0 auto;" }
_우선순위 변경이 필요한 상황_

만약 **우선순위 변경**이 없다면, A와 B는 계속 번갈아가며 스케줄링되지만 C와 D는 영원히 스케줄링될 수 없게 된다. 이를 방지하기 위해 **우선순위 변경**이 필요하다.

### **우선 순위 변경 방법**

1. 작업이 시스템에 진입하면 **가장 높은 우선순위**의 큐에 배치된다.
2. 작업이 주어진 **타임 슬라이스(Time Slice)** 를 모두 소진하면 **우선순위가 낮아져** 한 단계 아래의 큐로 이동한다.
3. 작업이 타임 슬라이스를 소진하기 전에 CPU를 양도하면, 현재 **우선순위를 유지**한다.

![alt text](/assets/img/OS/MLFQ/image-1.png){: style="width: 70%; display: block; margin: 0 auto;" }
_긴 작업의 우선순위 변화_
긴 실행 시간을 가진 작업은 처음에는 **최고 우선순위**로 시작하지만, 타임 슬라이스를 소진할 때마다 한 단계씩 아래로 내려가게 된다. 결국 최하위 큐에 도달하며, 이후에는 최하위 큐에 머무르게 된다.

![alt text](/assets/img/OS/MLFQ/image-2.png){: style="width: 70%; display: block; margin: 0 auto;" }
_오래 실행되는 작업(검은색)과 짧은 작업(회색)_
오래 실행되는 작업은 최하위 큐에 존재하게 된다. 이때 짧은 작업이 새로 들어오면 **최상위 큐**에 배치되며, 스케줄러는 짧은 작업을 먼저 스케줄링하여 빠르게 실행하고 종료시킨다. 짧은 작업은 최하위 큐로 내려가기 전에 작업을 끝마치게 된다.

> 스케줄러는 작업이 짧은 작업인지 긴 작업인지 알 수 없기 때문에 일단 짧은 작업이라고 가정하여 높은 우선순위를 부여한다. 진짜 짧은 작업이라면 빨리 실행되고 종료될 것이다. 반대로 긴 작업이라면 천천히 아래 큐로 이동하여 스스로 긴 작업임을 증명하게 된다. 이러한 방식으로 MLFQ는 SJF(Shortest Job First)를 근사할 수 있다.
{: .prompt-info }

![alt text](/assets/img/OS/MLFQ/image-3.png){: style="width: 70%; display: block; margin: 0 auto;" }
_긴 배치형 작업(검은색)과 대화형작업(회색)_

위 그림에서 **회색 작업**은 짧은 시간 동안 CPU를 사용한 뒤, **입출력(I/O)** 작업을 위해 CPU를 양도하는 **대화형 작업**이다. 대화형 작업은 **타임슬라이스(Time Slice)** 를 모두 소모하기 전에 CPU를 양도하므로, **우선순위가 유지**된다. MLFQ는 이러한 방식으로 **대화형 작업을 더 빨리 실행**시킬 수 있도록 설계되었다. 결과적으로, 대화형 작업은 최상위 우선순위 큐에 머물며 빠르게 처리되기 때문에 **사용자 경험(빠른 응답성)** 을 개선하는 데 기여한다.

---

### **현재 MLFQ의 문제점**

1. **기아 상태(Starvation) 발생**  
   - 대화형 작업이 과도하게 많을 경우, 이들이 CPU 시간을 독점하게 되어 긴 실행 시간 작업은 **CPU 할당**을 받지 못하는 상황이 발생할 수 있다.

2. **스케줄링 방식의 악용 가능성**  
   - 사용자가 MLFQ의 특성을 이용해 CPU **타임슬라이스의 99%** 를 사용한 후 CPU를 양도하는 방식으로 **CPU를 독점**할 수 있다. 이는 공정한 자원 배분을 방해할 수 있다.

3. **프로그램 특성 변화 반영의 어려움**  
   - 작업의 특성이 시간에 따라 변화할 수 있다.  
     예를 들어, CPU 중심 작업이 대화형 작업으로 바뀌는 경우, 현재 MLFQ는 이러한 변화를 효과적으로 반영하지 못해 해당 작업이 여전히 낮은 우선순위로 처리될 가능성이 있다.

### **우선순위의 상향 조정**

MLFQ는 **주기적으로 모든 작업의 우선순위를 상향 조정**하는 방법을 통해 다음과 같은 문제를 해결할 수 있다.

1. **기아 상태(Starvation) 방지**  
   - 모든 작업은 일정 주기마다 우선순위가 상향되므로, 긴 실행 시간 작업도 결국 높은 우선순위를 받아 **CPU 시간을 할당받을 수 있게 된다**.

2. **프로그램 특성 변화 반영**  
   - 작업의 특성이 변화한 경우, 상향된 우선순위에서 프로그램의 특성에 맞게 **우선순위가 재조정**될 수 있다.  
     이를 통해, CPU 중심 작업이 대화형 작업으로 바뀌는 상황도 적절히 반영할 수 있다.

### **더 나은 시간 측정**

MLFQ는 **각 단계에서 CPU의 총 사용 시간을 측정**함으로써, 스케줄러를 악용하여 유리하게 동작시키는 행위를 방지할 수 있다.

#### **시간 측정 및 우선순위 강등 방식**
- 스케줄러는 **현재 큐에서 프로세스가 소진한 CPU 사용 시간**을 저장한다.
- 프로세스가 타임 슬라이스에 해당하는 CPU 사용 시간을 모두 소진하면 **다음 우선순위 큐로 강등**된다.
- 타임 슬라이스를 한 번에 모두 사용하든, 짧게 여러 번 나누어 사용하든 총 사용 시간을 기준으로 판단하기 때문에 동일하게 처리된다.


![alt text](/assets/img/OS/MLFQ/image-4.png){: style="width: 70%; display: block; margin: 0 auto;" }
_조작에 대한 내성이 없는 경우(좌측)와 있는 경우(우측)_

- **좌측: 내성이 없는 경우**  
  - 타임 슬라이스를 모두 소진하지 않고 CPU를 양도하는 프로그램이 CPU를 거의 독점할 수 있다.

- **우측: 내성이 있는 경우**  
  - CPU 사용 시간을 측정하여 타임 슬라이스 소진 여부와 관계없이 **우선순위를 조정**한다.  
    이러한 방식으로 **악용을 방지**하고 공정한 스케줄링을 유지할 수 있다.

> MLFQ 스케줄링에는 여전히 해결해야 할 여러 쟁점이 존재한다. 스케줄러가 필요한 변수들을 어떻게 설정할 것인가도 중요한 문제 중 하나다. 예를 들어, 큐의 개수는 몇 개가 적절한지, 각 큐의 타임 슬라이스 크기를 어떻게 설정해야 하는지, 기아 상태를 방지하고 작업 특성의 변화를 반영하기 위해 우선순위를 얼마나 자주 상향 조정해야 하는지 등이 포함된다. 이러한 질문에 대해 명확한 정답을 제시하기는 어렵다. 워크로드에 대한 충분한 경험을 바탕으로 지속적으로 조정해 나가면서 시스템과 작업 환경에 맞는 최적의 균형점을 찾아야 한다.
{: .prompt-tip }


### **MLFQ 조정과 다른 쟁점들**

MLFQ 스케줄링에는 아직 해결해야 할 여러 **쟁점**이 존재한다. 특히, 스케줄러가 필요로 하는 다양한 변수를 어떻게 설정할지에 대한 문제가 중요하다. 

#### 주요 쟁점
1. **큐의 개수**  
   - 몇 개의 큐를 생성해야 효율적인 스케줄링이 가능한가?

2. **타임 슬라이스의 크기**  
   - 각 큐에서 **타임 슬라이스(Time Slice)** 를 얼마나 설정해야 하는가?

3. **우선순위 상향 조정 주기**  
   - 기아 상태를 방지하고 프로그램 특성의 변화를 반영하기 위해, 우선순위를 얼마나 자주 상향 조정해야 하는가?

#### 해결 접근 방식
이러한 질문들에 대해 명확한 정답은 없으며, 스케줄링의 최적화를 위해서는 **워크로드**에 대한 충분한 경험과 지속적인 조정이 필요하다.  
이를 통해 시스템의 요구와 작업 특성에 적합한 **균형점**을 찾아야 한다.

---

## MLFQ 요약

1. **규칙 1**:  
   - 우선순위(A) > 우선순위(B)인 경우, **A가 실행**되고 **B는 대기**한다.

2. **규칙 2**:  
   - 우선순위(A) = 우선순위(B)인 경우, A와 B는 **라운드 로빈(RR)** 방식으로 실행된다.

3. **규칙 3**:  
   - 새로운 작업이 시스템에 들어오면 **최상위 큐**에 배치된다.

4. **규칙 4**:  
   - 작업이 현재 단계에서 배정받은 **CPU 시간을 모두 소진**하면 (CPU를 포기한 횟수와 상관없이) **우선순위가 감소**하며, 한 단계 아래 큐로 이동한다.

5. **규칙 5**:  
   - 일정 주기 **S**가 지나면 시스템의 **모든 작업을 최상위 큐로 이동**시킨다.

MLFQ는 이러한 규칙을 기반으로 **작업 반환 시간 최적화**와 **대화형 작업의 빠른 응답성**을 제공하며, 동시에 **기아 상태 방지**와 **작업 특성 반영**을 목표로 한다.