---
title: 주소 변환의 원리
date: 2024-12-04 18:00:00 +09:00
categories: [OS, Virtualization]
tags:
  [operating system, ostep, 메모리 가상화]
---

## **주소 변환(adress translation)**
운영체제는 메모리 가상화를 위해 **주소 변환(Address Translation)**을 수행한다. 주소 변환은 프로그램의 가상 주소를 실제 데이터가 저장된 물리 주소로 변환하는 과정이다. 이 과정에는 하드웨어뿐만 아니라 운영체제의 관리가 필요하다. 운영체제는 메모리의 사용 현황을 항상 파악하고, 이를 제어 및 관리한다.

주소 변환 덕분에 프로그램은 자신만의 독립적인 메모리를 소유하고 있다고 느끼지만, 실제로는 여러 프로그램이 물리 메모리를 공유하고 있다.

---

### 예시

다음과 같은 C 코드가 있다고 가정하자.

```c
void func() {
int x = 3000;
x = x + 3;
```

컴파일러는 이 코드를 어셈블리 코드로 변환하며, 결과는 다음과 같다.

```
128: movl 0x0(%ebx), %eax ; #ebx의 값에 0을 더한 위치에서 데이터를 읽어 eax에 저장
132: addl $0x03, %eax     ; #eax 레지스터에 3을 더함
135: movl %eax, 0x0(%ebx) ; #eax 값을 다시 메모리에 저장
```

이 명령어 실행 과정에서 메모리 접근은 다음과 같은 단계를 거친다.
1. 주소 128의 명령어를 가져옴
2. 명령어 실행 (데이터를 물리 메모리 주소 15KB에서 읽음)
3. 주소 132의 명령어를 가져옴
4. 명령어 실행 (메모리 참조 없음)
5. 주소 135의 명령어를 가져옴
6. 명령어 실행 (데이터를 15KB에 저장)

이 프로그램은 논리적으로 주소 0부터 시작하여 최대 16KB까지의 메모리를 사용하는 것처럼 동작한다. 하지만 실제로는 운영체제가 물리 메모리 내 다른 위치에 프로그램을 배치한다.

![alt text](/assets/img/OS/주소%20변환의%20원리/image.png){: style="width: 30%; display: block; margin: 0 auto;" }
_프로세스와 그 주소 공간_

--- 

## **동적(하드웨어-기반) 재배치**
동적 재배치는 실행 중인 프로그램의 주소 공간을 물리 메모리 내에서 자유롭게 배치하거나 이동할 수 있는 기술이다. 이를 위해 CPU에는 두 개의 하드웨어 레지스터인 **베이스(Base)**와 **바운드(Bound)**가 필요하다.

### **베이스와 바운드(base and bound)**
- **베이스 레지스터**: 프로그램이 시작될 물리 메모리 위치를 저장하며, 모든 가상 주소에 더해져 실제 물리 주소를 계산한다.
- **바운드 레지스터**: 프로그램의 메모리 참조가 지정된 범위를 벗어나지 않도록 확인한다.

모든 주소는 실행 시 하드웨어에 의해 변환되며, 이 과정은 **메모리 관리 장치(MMU, Memory Management Unit)**가 담당한다. 잘못된 메모리 접근이 발생하면 CPU는 예외를 발생시키고 프로그램을 종료할 수 있다.

#### 예시
주소 공간의 크기가 4KB이고 물리 주소 16KB에 프로그램이 탑재되었다고 가정하면, 주소 변환 결과는 다음과 같다.

![alt text](/assets/img/OS/주소%20변환의%20원리/image-1.png)
_주소 변환 결과_

### 요구사항

#### 하드웨어 요구사항

- 특권 모드(커널 모드)를 지원하여 사용자 프로세스가 시스템 명령어를 실행하지 못하도록 해야 한다.
- 각 CPU에 베이스와 바운드 레지스터 한 쌍이 필요하다.
- 가상 주소 변환과 범위 검사 기능이 필요하다.
- 운영체제가 베이스와 바운드 레지스터 값을 설정할 수 있는 특권 명령어를 제공해야 한다.
- 메모리 접근 오류 시 예외를 발생시키는 기능이 필요하다.

#### 운영체제 요구사항

1. 메모리 할당 및 관리
    - 새로운 프로세스 생성 시 사용 가능한 메모리 공간을 찾아 할당한다.
    - 종료된 프로세스의 메모리를 회수하여 재사용한다.
2. 문맥 교환
    - 프로세스 전환 시 베이스와 바운드 레지스터 값을 저장하고 복원한다.
    - 프로세스 구조체(PCB)에 레지스터 값을 기록한다.
3. 주소 재배치
    - 프로세스 실행 중에도 메모리 위치를 변경할 수 있으며, 이 경우 PCB의 베이스 값을 갱신한다.
4. 예외 처리
    - 잘못된 메모리 접근 시 운영체제가 호출될 핸들러를 제공해야 한다.

> 운영체제는 메모리 할당 관리를 위해 공간 리스트(Free List) 같은 자료구조를 사용하며, 이는 사용 중이지 않은 물리 메모리 영역의 목록을 유지한다.
{: .prompt-tip }
