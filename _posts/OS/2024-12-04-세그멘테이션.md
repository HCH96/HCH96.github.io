---
title: 세그멘테이션
date: 2024-12-04 20:00:00 +09:00
categories: [OS, Virtualization]
tags:
  [operating system, ostep, 메모리 가상화, segmentation]
---

## **세그멘테이션: 메모리 관리 기법**

**세그멘테이션**은 가상 주소를 물리 주소로 매핑할 때 가상 주소 공간을 논리적인 단위인 **세그먼트(segment)**로 나누고, 각 세그먼트를 물리 메모리에 독립적으로 매핑하는 방식이다. 이를 통해 메모리 낭비를 줄이고 효율적인 메모리 사용을 지원한다.

## **세그멘테이션의 필요성**
- 기존 방식(베이스/바운드 레지스터 1쌍): 사용하지 않는 주소 공간도 물리 메모리를 차지하여 메모리 낭비 발생.

- **세그멘테이션**: 가상 주소를 코드, 힙, 스택 등의 세그먼트로 나누고, 물리 메모리의 서로 다른 위치에 배치.
    - **스파스 주소 공간(Sparse Address Space)**: 힙과 스택 사이처럼 사용되지 않는 공간을 물리 메모리에 할당하지 않음.

![alt text](/assets/img/OS/세그멘테이션/image.png){: style="width: 30%; display: block; margin: 0 auto;" }
_주소 공간에서 스택과 힙 사이의 sparse address space_

> 위의 그림에서는 힙과 스택이 화살표 방향으로 확장되는 것처럼 보이지만, 실제로 동적 메모리를 할당할 때는 힙 영역 내부에서 메모리가 할당된다. 그림의 화살표는 sbrk() 시스템 호출을 통해 힙 영역이 확장되는 과정을 나타낸다. 마찬가지로, 스택에서도 push나 pop 연산으로 스택 포인터가 움직일 때는 스택 영역 내부에서 메모리가 할당된다.
{: .prompt-warning }

## **세그멘테이션을 위한 MMU의 지원**
세그먼트를 지원하기 위해 MMU는 각각의 세그먼트에 대한 베이스 바운드 쌍을 저장할 수 있어야 한다. 각 베이스에는 해당 세그먼트의 물리 메모리에서의 시작 위치를 저장하고, 바운드 레지스터는 세그멘트의 크기를 저장한다.

![alt text](/assets/img/OS/세그멘테이션/image-1.png){: style="width: 50%; display: block; margin: 0 auto;" }
_물리 메모리에 세그멘트 배치하기_

![alt text](/assets/img/OS/세그멘테이션/image-2.png)
_세그멘트 레지스터의 값_

--- 
## **세그멘트 파악**
하드웨어는 변환을 위해 세그먼트 레지스터를 사용한다. 하드웨어는 가상 주소가 어느 세그멘트를 참조하는지 그리고 그 세그멘트 안에서 오프셋은 얼마인지를 알 수 있어야 한다.

일반적 접근 방식으로는 가상 주소의 최상위 몇 비트를 기준으로 주소 공간을 여러개의 세그먼트로 나누는 것이다. 위의 예에서는 3개의 세그멘트가 존재한다. 따라서 주소 공간을 세그멘트로 나누기 위해서는 2비트가 필요하다. 세그멘트를 표시하기 위해 최상위 2비트를 사용하고 나머지 비트는 해당 세그멘트의 오프셋으로 이용한다.

![alt text](/assets/img/OS/세그멘테이션/image-3.png){: style="width: 70%; display: block; margin: 0 auto;" }
_가상주소를 통한 세그먼트 이용의 예시_

이런 예시에서 최상위 비트 2개가 00이면, 하드웨어는 가상 주소가 코드 세그멘트를 가리킨다는 것을 알고, 따라서 코드 세그멘트의 베이스와 바운드 쌍을 사용하여 주소를 정확한 물리 메모리에 재배치한다.

> 묵시적 접근 방식 : 특정 주소의 세그멘트를 하드웨어적으로 판단하는 방법, 예를 들어 PC에서 메모리 참조를 할 경우 해당 세그먼트는 코드 영역의 세그먼트일 것이고, 스택 포인터가 메모리를 참조할 경우 스택이 속한 세그먼트임을 알수 있다.
{: .prompt-tip }


## **스택 세그멘트 특성**
스택 세그먼트는 다른 세그먼트와 달리 반대 방향으로 확장된다. 예를 들어, 위의 예시에서는 가상 주소 16KB에서 14KB까지 스택이 할당되고, 물리 메모리에서는 28KB에서 26KB로 할당된다. 이러한 특성 때문에 MMU는 베이스와 바운드 값뿐만 아니라 세그먼트의 확장 방향도 알아야 하며, 주소 변환 방식 역시 일반 세그먼트와 다르게 처리해야 한다.

### 주소 변환 방식
최상위 두 비트를 사용해 세그먼트의 종류를 파악하는 방식은 동일하다. 최상위 두 비트를 제외한 나머지 비트는 해당 세그먼트 내의 **오프셋(offset)**을 나타낸다. 스택 세그먼트의 경우, 이 오프셋은 스택의 시작 지점이 아니라 세그먼트의 시작 지점을 기준으로 계산된다.

예를 들어, 가상 주소가 15KB일 경우, 이를 비트로 나타내면 11 1100 0000 0000이 되는데, 최상위 두 비트를 제외한 오프셋은 1100 0000 0000으로 3KB에 해당한다. 이 오프셋의 시작 지점은 스택 세그먼트의 시작인 16KB가 아니라, 세그먼트의 시작점인 12KB이 된다. 따라서 계산은 12KB(세그먼트의 시작) + 3KB(오프셋)이 된다.

스택 세그먼트에서 물리 주소를 얻으려면, 오프셋 크기에서 세그먼트 크기를 뺀 뒤, 해당 값을 세그먼트의 베이스 주소에 더해야 올바른 물리 주소를 계산할 수 있다.

## **주소 변환 예시**

1. 가상 주소가 100일 경우 물리 주소를 계산하기
    - 100은 최상위 2비트가 00이므로 코드영역 세그멘트에 존재한다.
    - 코드영역 세그멘트의 base는 32KB, 바운드는 2KB
    - 2KB > 100 이므로 유효한 메모리이다.
    - 실제 메모리 주소 = 32KB + 100 -> 32868

2. 가상 주소가 4200인 경우 물리 주소 계산하기
    - 4200를 비트로 나타내면 01 0000 0110 1000
    - 최상위 2비트가 01이므로 힙 세그멘트에 존재한다.
    - 힙 세그멘트의 base는 34KB, 바운드는 2KB
    - 오프셋은 최상위 2비트를 제외한 값이고, 2KB > 104 이므로 유효한 메모리이다.
    - 실제 메모리 주소 = 34KB + 104 = 34920

3. 가상 주소가 6KB일 경우 물리 주소 계산하기
    - 힙 영역의 크기는 2KB, 힙의 시작 4KB에서 2KB 떨어진 곳은 (6KB-1)이다. 
    - 따라서 바운드의 범위를 벗어났다->segmentation fault

4. 가상 주소가 15KB인 경우 물리 주소 계산하기
    - 15KB를 비트로 나타내면 11 1100 0000 0000
    - 최상위 비트가 11이므로 스택 세그멘트에 존재한다.
    - 스택은 역방향이기 때문에, 물리 메모리에서의 오프셋 = 3KB(오프셋의 크기)-4KB(세그멘트의 크기) = -1KB
    - |-1KB| < 2KB 이므로 유효한 메모리이다.
    - 실제 메모리 주소 = 28KB - 1KB = 27KB

---

## **공유 지원**

메모리를 절약하기 위해, 여러 주소 공간에서 특정 메모리 세그먼트를 공유하는 것이 유용하다. 이를 지원하기 위해 하드웨어에는 **보호 비트(Protection Bit)**가 추가된다. 보호 비트는 세그먼트별로 설정되어 해당 세그먼트를 읽거나 쓸 수 있는지, 또는 실행할 수 있는지를 제어한다.

![alt text](/assets/img/OS/세그멘테이션/image-4.png){: style="width: 70%; display: block; margin: 0 auto;" }
_세그멘트 레지스터 값(보호 정보 포함)_

예를 들어, 동일한 프로그램을 실행하는 두 개의 프로세스가 있을 경우, 물리 메모리에는 하나의 코드 영역만 있어도 충분하다. 이 경우, 물리 메모리에 단일 코드 영역을 할당한 뒤, 두 프로세스의 세그먼트 테이블에서 코드 영역의 베이스와 바운드를 동일하게 설정하여 공유를 할 수 있다.

---
### **세그멘테이션 유형**

1. **대단위(coarse-grained)** 세그멘테이션
    - 주소 공간을 비교적 큰 단위의 공간으로 분할하는 세그멘테이션
    - 위의 예시처럼 세그멘트를 코드,스택,힙만으로 나누는 경우가 대단위 세그멘테이션 이다.

2. **소단위(fine-grained)** 세그멘테이션
    - 주소 공간을 작은 크기의 공간으로 잘게 나누는 세그멘테이션
    - 많은 수의 세그멘트를 지원하기 위해 여러 세그멘트의 정보를 메모리에 저장할 수 있는 세그멘트 테이블이 필요하다.

---
### 운영체제의 역할과 외부 단편화

1. 운영체제 역할
    - 문맥 교환 시 세그먼트 레지스터 저장 및 복원.
    - 새로운 세그먼트를 위한 물리 메모리 공간 관리.
2. 외부 단편화 문제
    - 물리 메모리가 작은 빈 공간으로 나뉘어 새 세그먼트를 배치하거나 확장하기 어려움.

**해결 방법**
1. 메모리 압축(Compaction): 세그먼트를 정리해 연속된 빈 공간 생성.
    - 단점: 세그먼트 복사 비용이 높음.
2. 빈 공간 관리 알고리즘:
    - Best-fit, Worst-fit, First-fit, Buddy Algorithm 등 사용해 효율적 공간 배치.

![alt text](/assets/img/OS/세그멘테이션/image-5.png){: style="width: 70%; display: block; margin: 0 auto;" }
_압축 전과 합축 후의 메모리 상태_
