---
title: 페이징 - 더 작은 테이블
date: 2024-12-06 20:00:00 +09:00
categories: [OS, Virtualization]
math: true
tags:
  [operating system, ostep, 페이징]
---

## **페이징의 문제점: 페이지 테이블의 크기**

페이징 방식에서는 프로세스의 가상 주소 공간과 물리적 메모리 간의 매핑을 관리하기 위해 페이지 테이블이 필요하다. 그러나 페이지 테이블의 크기가 지나치게 커질 경우 시스템의 메모리 자원을 크게 소모하는 문제가 발생한다.

### 1. **32비트 주소 공간과 4KB 페이지의 경우**
- 32비트 주소 공간은 $$2^{32}$$ 바이트(4GB)로 구성된다.
- 한 페이지의 크기가 4KB라면, 전체 주소 공간은 $$ \frac{2^{32}}{2^{12}} = 2^{20} $$개의 페이지로 나뉜다. 이는 약 백만 개의 페이지를 의미한다.
- 페이지 테이블의 각 항목이 4바이트라면, 단일 페이지 테이블의 크기는:
  $$
  2^{20} \times 4\ \text{바이트} = 4\ \text{MB}
  $$

### 2. **다중 프로세스 환경에서의 문제**
- 페이지 테이블은 프로세스마다 별도로 생성된다.
- 만약 시스템에 100개의 프로세스가 실행 중이라면, 전체 페이지 테이블의 크기는:
  $$
  4\ \text{MB} \times 100\ \text{프로세스} = 400\ \text{MB}
  $$
- 이는 메모리의 상당 부분을 페이지 테이블 관리에 사용하게 되어 성능 저하로 이어질 수 있다.

### 3. **64비트 주소 공간에서의 심화**
- 64비트 주소 공간에서는 $$2^{64}$$ 바이트로 확장되며, 페이지 수와 페이지 테이블의 크기가 기하급수적으로 증가한다. 이로 인해 메모리와 성능 문제는 더욱 심각해진다.

---

## **해결 방안**

### **더 큰 페이지**
페이지 테이블의 크기를 줄이는 간단한 방법 중 하나는 **페이지 크기를 증가시키는 것**이다. 페이지 크기를 키움으로써 페이지 테이블 항목 수를 줄일 수 있으며, 이에 따라 페이지 테이블의 전체 크기도 감소한다. 이를 32비트 주소 공간과 16KB 페이지를 예로 들어 설명하면 다음과 같다.

1. **페이지 크기 증가에 따른 효과**
   - 16KB 페이지를 사용할 경우, 주소 공간에서 **18비트의 VPN**과 **14비트의 오프셋**이 필요하다.
   - 페이지 테이블 항목 수는 $$2^{18}$$개로 줄어들며, 각 PTE(Page Table Entry)의 크기가 4바이트일 때 페이지 테이블의 총 크기는:
     $$
     2^{18} \times 4\ \text{바이트} = 1\ \text{MB}
     $$
   - 이는 기존 4KB 페이지를 사용했을 때와 비교해 페이지 테이블 크기가 **1/4로 감소**한 것이다. 페이지 크기를 4배로 늘렸기 때문이다.

2. **페이지 크기 증가의 부작용**
   - **내부 단편화(Internal Fragmentation):**
     - 페이지 크기가 커지면 **페이지 내부의 낭비 공간**이 증가한다.
     - 이는 응용 프로그램이 할당받은 페이지의 일부만 사용할 경우 발생하는 낭비로, 시스템 메모리가 더 빨리 소진되는 문제로 이어진다.
   - 이 때문에 많은 컴퓨터 시스템에서는 상대적으로 **작은 페이지 크기**를 유지한다. 예를 들어:
     - **x86 아키텍처**에서는 4KB 페이지 크기를 사용한다.
     - **SPARCv9 아키텍처**에서는 8KB 페이지 크기를 사용한다.

3. **결론**
   - 페이지 크기를 늘리면 페이지 테이블 크기를 줄일 수 있지만, 내부 단편화와 같은 문제가 발생한다.
   - 이러한 이유로 대부분의 시스템은 **4KB** 또는 **8KB**와 같은 비교적 작은 페이지 크기를 사용하여 메모리 낭비를 최소화하고 있다.

페이지 테이블의 크기를 줄이는 문제는 단순히 페이지 크기를 늘리는 것으로 완전히 해결되지 않는다. 이 문제를 해결하기 위해서는 페이지 크기와 내부 단편화 사이에서 적절한 균형을 찾는 것이 중요하다.

---

### **하이브리드 페이징-세그멘테이션**
페이지 테이블의 크기를 줄이는 방법 중 하나는 **페이징과 세그멘테이션**을 결합하는 것이다. 이 방법은 페이지 테이블의 크기를 줄이는 동시에 메모리 낭비를 완화할 수 있다.

#### **페이지 테이블의 낭비**
페이지 테이블의 낭비를 예로 들어보자. **1KB 크기의 페이지**와 **16KB의 가상 주소 공간**이 있다고 가정하면 다음과 같은 상황이 발생한다.

![alt text](/assets/img/OS/더%20작은%20테이블/image.png)
_1KB 페이지들로 이루어진 16KB 주소 공간_

![alt text](/assets/img/OS/더%20작은%20테이블/image-1.png)
_16KB 주소 공간을 위한 페이지 테이블_

1. **주소 공간과 페이지 테이블 구성**  
   - 가상 주소 공간은 총 16KB로, 각 페이지가 1KB이므로 페이지 번호(VPN)는 총 16개이다.  
   - 이에 따라 페이지 테이블은 각 페이지에 대한 매핑 정보를 저장한다.

2. **예제 매핑**  
   다음은 페이지 테이블의 예제이다:
   - **VPN 0**: 코드 페이지가 **물리 페이지 10번**에 매핑되어 있다.
   - **VPN 4**: 힙 페이지가 **물리 페이지 23번**에 매핑되어 있다.
   - **VPN 14, 15**: 가상 주소 공간 끝부분의 스택 페이지가 각각 **물리 페이지 28번**과 **4번**에 매핑되어 있다.

3. **낭비되는 공간**  
   페이지 테이블의 대부분은 비어 있다. 이는 페이지 테이블 항목의 많은 부분이 사용되지 않아 **큰 메모리 낭비**를 초래한다. 예를 들어, 위의 예에서는 16개의 페이지 중 일부만 실제로 사용되고, 나머지는 낭비되고 있다.

#### **페이징-세그멘테이션의 결합 효과**

페이징과 세그멘테이션을 결합하면 페이지 테이블의 낭비를 줄일 수 있다:
- **세그멘테이션**은 가상 주소 공간을 의미 있는 단위(코드, 데이터, 스택 등)로 분할하여 페이지 테이블이 사용하지 않는 공간을 포함하지 않도록 한다.
- **페이징**은 세그먼트를 다시 작은 페이지로 나누어 세그먼트 내의 메모리 관리를 효율화한다.


#### **결합 방식**
하이브리드 **페이징-세그멘테이션** 방식에서는, 프로세스의 전체 주소 공간에 하나의 페이지 테이블을 두는 대신, **논리 세그먼트마다 별도의 페이지 테이블**을 두는 방식으로 동작한다.

#### **구성 요소**
1. **세그멘테이션의 레지스터**  
   세그멘테이션은 다음 두 가지 레지스터를 활용하여 주소 변환을 수행한다:
   - **베이스(Base) 레지스터**: 세그먼트의 시작 주소 대신, **세그먼트 페이지 테이블의 시작 물리 주소**를 나타낸다.
   - **바운드(Bound) 또는 리미트(Limit) 레지스터**: 페이지 테이블의 끝을 나타내며, **세그먼트 내의 최대 유효 페이지 수**를 나타낸다.

2. **페이지 테이블 구조의 변화**  
   - 각 논리 세그먼트는 독립적인 페이지 테이블을 가진다.
   - 논리 세그먼트는 코드, 데이터, 스택 등과 같은 의미 있는 단위로 나뉘며, 이 단위별로 페이지 테이블이 관리된다.
   - 가상 주소는 **세그먼트 번호**와 **오프셋**으로 구성된다:
     - 세그먼트 번호는 적절한 페이지 테이블을 선택하기 위해 사용된다.
     - 오프셋은 해당 페이지 테이블에서 물리 주소를 계산하는 데 사용된다.

#### **작동 방식**
![alt text](/assets/img/OS/더%20작은%20테이블/image-2.png)

1. **예제 가정**  
   - **32비트 가상 주소 공간**이 4개의 세그먼트로 나뉘어 있다.
   - 각 세그먼트는 다음과 같은 비트를 사용해 구분된다:
     - `00`: 미사용 세그먼트
     - `01`: 코드 세그먼트
     - `10`: 힙 세그먼트
     - `11`: 스택 세그먼트
   - 가상 주소는 세그먼트 비트(SN)와 나머지 주소(VPN, 오프셋)로 구성된다.

2. **레지스터 동작**  
   - **베이스 레지스터**는 현재 프로세스의 각 세그먼트 페이지 테이블 시작 주소를 저장한다.
   - **바운드 레지스터**는 각 세그먼트의 유효 페이지 수를 저장한다.
   - 문맥 교환(Context Switch) 시, 레지스터 값은 새 프로세스의 페이지 테이블 주소로 갱신된다.

3. **TLB 미스 처리**  
   - **TLB 미스**가 발생하면 하드웨어는 가상 주소의 **세그먼트 비트(SN)**를 사용해 적절한 베이스/바운드 레지스터 쌍을 선택한다.
   - 하드웨어는 아래와 같은 방식으로 페이지 테이블 항목(PTE)의 주소를 계산한다:
     ```
     SN = (VirtualAddress & SEG_MASK) >> SN_SHIFT
     VPN = (VirtualAddress & VPN_MASK) >> VPN_SHIFT
     AddressOfPTE = Base[SN] + (VPN * sizeof(PTE))
     ```

4. **바운드 검증**  
   - 바운드 레지스터를 사용해 유효 범위를 초과하는 메모리 접근을 차단한다.
   - 예를 들어, 코드 세그먼트가 3개의 유효 페이지만 사용한다면, 바운드 레지스터 값은 `3`으로 설정된다.
   - 범위를 초과한 접근은 예외를 발생시키며, 해당 프로세스는 종료된다.

#### **장점**
1. **메모리 효율성 향상**  
   - 세그먼트별로 페이지 테이블 크기를 제한할 수 있다.
   - 스택과 힙 사이의 할당되지 않은 페이지는 더 이상 페이지 테이블에 공간을 차지하지 않는다.

2. **안전성 강화**  
   - 바운드 레지스터를 통해 불법적인 메모리 접근을 차단하여 안정성을 높인다.

3. **낭비 감소**  
   - 불필요한 페이지 테이블 공간을 제거함으로써 선형 페이지 테이블 방식에 비해 메모리 사용을 최적화할 수 있다.

#### **하이브리드 기법의 한계**
1. **세그멘테이션의 한계**
   - 하이브리드 기법에서는 여전히 **세그멘테이션**을 사용해야 한다.
   - 세그멘테이션은 **주소 공간 사용 패턴**에 대한 특정 가정을 전제로 하며, 원하는 만큼 유연하지 못하다.
   - 특히, **드문드문 사용되는 힙(Sparsely Used Heap)**의 경우, 페이지 테이블 낭비를 완전히 제거하지 못할 가능성이 있다.

2. **외부 단편화**
   - 하이브리드 방식에서는 각 세그먼트의 페이지 테이블 크기에 제한이 존재하며, 다양한 크기를 갖는다.
   - 페이지 테이블의 크기는 **페이지 테이블 항목 크기의 정수배**가 되어야 하므로, 메모리 상에서 페이지 테이블 용 공간을 확보하는 과정이 더 복잡하다.
   - 이로 인해, **외부 단편화(External Fragmentation)** 문제가 발생할 수 있다.

3. **완전한 해결책의 부재**
   - 이러한 단점으로 인해 하이브리드 기법도 주소 공간 관리 문제를 완전히 해결하지 못한다.
   - 결과적으로, **페이지 테이블 크기를 줄이는 더 나은 방법**을 찾기 위한 연구와 개발이 계속되고 있다.

### **결론**
하이브리드 페이징-세그멘테이션 기법은 주소 공간 관리에서 메모리 효율성과 안정성을 어느 정도 개선했지만, 여전히 일부 단점이 존재한다. 세그멘테이션의 한계와 외부 단편화 문제는 이 기법이 완벽하지 않음을 보여주며, 더 나은 해결책을 찾기 위한 노력이 지속되고 있다.

---

### **멀티 레벨 페이지 테이블**

멀티 레벨 페이지 테이블은 **선형 페이지 테이블을 트리 구조**로 변환하여 페이지 테이블 크기를 줄이는 기법이다. 사용되지 않는 주소 공간을 페이지 테이블에서 제거함으로써 효율적인 메모리 관리를 가능하게 하며, 많은 현대 시스템에서 널리 사용되고 있다.

![alt text](/assets/img/OS/더%20작은%20테이블/image-3.png)
_선형(좌) 그리구 멀티 레벨(우) 페이지 테이블_

#### **기본 원리**

1. **페이지 테이블 분할**  
   - 페이지 테이블을 **페이지 크기 단위로 나눈다.**
   - 사용되지 않는 페이지 테이블의 페이지는 할당하지 않는다.

2. **페이지 디렉터리(Page Directory)**  
   - 각 페이지 테이블의 페이지가 **할당되었는지 여부와 위치**를 저장하는 자료 구조이다.
   - 유효(valid) 비트와 페이지 프레임 번호(Page Frame Number, PFN)를 포함하며, 최소한 하나의 유효 항목이 있는 페이지만 페이지 디렉터리에 등록된다.

#### **장점**

1. **효율적인 메모리 사용**  
   - 사용된 주소 공간의 크기에 비례하여 페이지 테이블이 동적으로 할당된다.
   - 사용되지 않는 페이지 테이블 공간이 제거되므로 메모리 낭비를 줄일 수 있다.

2. **유연한 페이지 테이블 관리**  
   - 페이지 테이블을 **페이지 단위**로 나누어 관리하므로, 연속된 물리 메모리를 요구하지 않는다.
   - 페이지 테이블이 메모리에 산재해 있어도 페이지 디렉터리를 통해 효율적으로 관리할 수 있다.

### **예제**

멀티 레벨 페이지 테이블의 개념을 이해하기 위해, **64바이트 페이지**와 **16KB 주소 공간**을 사용하는 간단한 예제를 살펴보자.

![alt text](/assets/img/OS/더%20작은%20테이블/image-4.png)
_64바이트 페이지들로 이루어진 16KB 주소 공간_

#### **기본 구성**

1. **주소 공간**
   - **14비트 가상 주소**:  
     - **8비트 VPN(Virtual Page Number)**  
     - **6비트 오프셋(Offset)**
   - 총 256개의 페이지(VPN)로 구성되며, 각각의 크기는 64바이트이다.

2. **선형 페이지 테이블**
   - 총 256개의 PTE(Page Table Entry)로 구성.
   - 각 PTE의 크기는 4바이트.
   - 페이지 테이블의 총 크기:
     $$
     256 \times 4\ \text{바이트} = 1\ \text{KB}
     $$

3. **주소 공간 활용**
   - 사용된 가상 페이지:
     - **0, 1**: 코드(Code)
     - **4, 5**: 힙(Heap)
     - **254, 255**: 스택(Stack)
   - 나머지 페이지는 사용되지 않음.

#### **2단계 페이지 테이블 구성**

1. **페이지 테이블 분할**
   - 1KB의 페이지 테이블을 **64바이트 단위로 분할**:
     - 총 **16개의 페이지**로 나누어짐.
     - 각 페이지는 16개의 PTE를 포함.

2. **페이지 디렉터리 구성**
   - **페이지 디렉터리(Page Directory)**:
     - 16개의 항목(PDE)로 구성.
     - 각 PDE는 페이지 테이블의 한 페이지를 가리킴.
   - VPN의 **상위 4비트**를 사용해 페이지 디렉터리 인덱스를 계산.


#### **주소 변환 절차**

1. **페이지 디렉터리 접근**
   - VPN의 상위 4비트 → **페이지 디렉터리 인덱스**.
   - PDE를 읽어 페이지 테이블의 물리 주소를 확인.

![alt text](/assets/img/OS/더%20작은%20테이블/image-5.png)

2. **페이지 테이블 접근**
   - VPN의 하위 4비트 → **페이지 테이블 인덱스**.
   - 페이지 테이블 페이지에서 PTE를 가져옴.

![alt text](/assets/img/OS/더%20작은%20테이블/image-6.png)

3. **물리 주소 계산**
   - PTE에서 페이지 프레임 번호(PFN)를 확인하고 오프셋을 결합:
     $$
     \text{PhysAddr} = (\text{PTE.PFN} \ll \text{SHIFT}) + \text{Offset}
     $$

#### **예제: VPN 254의 변환**

![alt text](/assets/img/OS/더%20작은%20테이블/image-7.png)
_페이지 디렉터리와 페이지 테이블의 일부_

1. **가상 주소**: 0x3F80 (이진수: `11111110000000`)
   - VPN = 254, 오프셋 = 0.

2. **페이지 디렉터리 접근**
   - VPN 상위 4비트 = `1111` → 페이지 디렉터리의 15번째 항목(PDE).
   - PDE는 페이지 테이블의 물리 주소(PFN = 101)를 가리킴.

3. **페이지 테이블 접근**
   - VPN 하위 4비트 = `1110` → 페이지 테이블의 15번째 페이지의 14번째 PTE.
   - PTE는 물리 페이지 번호(PFN = 55)를 저장.

4. **물리 주소 계산**
   - 물리 주소:
     $$
     \text{PhysAddr} = (55 \ll 6) + 0 = 0x0DC0
     $$


##### **TLB와의 관계**
- **TLB 히트**: 페이지 테이블을 참조하지 않고 바로 물리 주소를 구성한다.
- **TLB 미스**: 페이지 디렉터리와 페이지 테이블의 모든 단계를 거쳐 물리 주소를 계산한다. 이 과정에서 **두 번의 메모리 접근**이 필요하다.

#### **멀티 레벨 페이지 테이블의 예제**

##### **예제 1: 2단계 페이지 테이블**
- **64바이트 페이지와 16KB 주소 공간**을 가진 예제를 살펴보자.
- 선형 페이지 테이블 크기는 256개의 엔트리(PTE × 4바이트 = 1KB)이다.
- 이를 16개의 64바이트 페이지로 분할하여 **페이지 디렉터리와 페이지 테이블**을 구성한다:
  - 페이지 디렉터리는 16개의 엔트리를 가지고, 각 엔트리는 1개의 페이지를 가리킨다.
  - 사용되지 않는 페이지는 할당되지 않는다.

![alt text](/assets/img/OS/더%20작은%20테이블/image-8.png)

##### **예제 2: 3단계 이상 구조**
- 더 큰 주소 공간(예: 30비트 주소 공간)에서는 **단계를 추가**해야 한다.
- 페이지 크기가 512바이트, PTE 크기가 4바이트라면, 한 페이지에 128개의 PTE를 저장할 수 있다.
- 페이지 디렉터리가 너무 커질 경우, 이를 추가로 분할해 트리 구조를 형성한다:
  - 상위 단계 페이지 디렉터리를 추가로 생성한다.
  - 최상위 비트로 상위 페이지 디렉터리 인덱스를 계산하고, 하위 디렉터리를 참조해 최종 페이지 테이블을 찾는다.

![alt text](/assets/img/OS/더%20작은%20테이블/image-9.png)

#### **한계점과 단점**

1. **추가 메모리 접근 비용**
   - TLB 미스 시 **두 번의 메모리 접근**이 필요하다.  
     (페이지 디렉터리 접근 + 페이지 테이블 접근)

2. **구현 복잡성**
   - 선형 페이지 테이블에 비해 **구조가 복잡**하며, 페이지 테이블 검색 과정이 더 많은 계산을 요구한다.

3. **트레이드오프**  
   - 멀티 레벨 페이지 테이블은 공간 절약과 메모리 접근 시간을 상호 절충(time-space trade-off)한 방식이다.
   - 공간 절약에는 성공했지만, 메모리 접근 시간은 증가했다.


#### **결론**

멀티 레벨 페이지 테이블은 사용하지 않는 주소 공간을 제거하고 페이지 테이블의 크기를 줄이기 위한 효율적인 기법이다. 공간 절약 효과가 뛰어나지만, 추가 메모리 접근 비용과 구현 복잡성이라는 단점이 존재한다. TLB와 결합하여 성능을 최적화하며, 현대 시스템에서 널리 사용되는 페이지 테이블 관리 방식이다.

---

### **역 페이지 테이블 (Inverted Page Table)**

역 페이지 테이블은 **메모리 공간을 획기적으로 절약**하기 위한 기법이다. 기존 방식과 달리, **프로세스당 하나의 페이지 테이블** 대신 **시스템 전체에 하나의 페이지 테이블**만을 사용한다.


#### **구조와 동작 원리**

1. **기본 구조**
   - 역 페이지 테이블은 **물리 페이지를 기준**으로 구성된다.
   - 각 항목에는 다음과 같은 정보가 저장된다:
     - 해당 물리 페이지를 사용하는 **프로세스 번호**.
     - 해당 물리 페이지에 매핑된 **가상 페이지 번호**.

2. **역 페이지 테이블의 목적**
   - 가상 주소를 물리 주소로 변환하기 위해 사용된다.
   - 기존의 페이지 테이블이 **가상 주소 → 물리 주소**를 매핑하는 것과 달리, **물리 주소 → 가상 주소** 변환을 기반으로 동작한다.

#### **주소 변환 과정**
1. **탐색 방식**
   - 역 페이지 테이블을 검색하여, 특정 가상 주소 페이지에 해당하는 물리 페이지를 찾는다.
   - 순차 탐색은 비효율적이므로, 탐색 속도를 높이기 위해 **해시 테이블**을 사용하는 경우가 많다.

2. **해시 테이블 활용**
   - 해시 테이블을 통해 가상 주소를 해시 키로 변환하여, 빠르게 물리 페이지를 찾을 수 있다.
   - 예: PowerPC 아키텍처는 역 페이지 테이블과 해시 테이블을 결합하여 구현한다.

#### **장점과 단점**

1. **장점**
   - **공간 절약**: 프로세스별 페이지 테이블을 유지할 필요가 없으므로, 전체 페이지 테이블 크기가 감소한다.
   - **단일 테이블**: 시스템에 하나의 통합된 페이지 테이블만 존재하므로 관리가 간단하다.

2. **단점**
   - **탐색 비용**: 순차 탐색의 경우 느리며, 이를 해결하기 위해 해시 테이블 같은 추가적인 자료 구조가 필요하다.
   - **복잡성**: 해시 테이블 구현 및 관리로 인해 구조가 더 복잡해질 수 있다.

#### **일반적 관점**

- 역 페이지 테이블은 페이지 테이블 설계의 다양한 시도 중 하나로, **멀티 레벨 페이지 테이블**과 함께 대표적인 메모리 관리 기법이다.
- 자료 구조 설계에 따라 성능과 효율성이 크게 달라질 수 있다:
  - 크기와 속도를 조절할 수 있음.
  - 사용 사례에 따라 다르게 최적화 가능.

#### **결론**

역 페이지 테이블은 시스템 전체에 단일 페이지 테이블을 유지하면서, 물리 페이지를 가상 주소로 매핑하여 메모리 사용 효율을 높이는 기법이다. 해시 테이블을 활용해 탐색 성능을 개선할 수 있으며, PowerPC와 같은 아키텍처에서 실제로 사용되고 있다.

---

### **페이지 테이블의 저장 위치: 물리 메모리와 스왑**

#### **기본 가정**
- 지금까지는 페이지 테이블이 **커널 소유의 물리 메모리 영역**에 존재한다고 가정하였다.
- 하지만, 페이지 테이블의 크기를 줄이기 위한 다양한 시도가 이루어지더라도, 여전히 모든 페이지 테이블을 물리 메모리에 상주시킬 수 없는 경우가 있다.

#### **대안: 가상 메모리 활용**

1. **페이지 테이블의 가상 메모리 이동**
   - 일부 시스템에서는 **페이지 테이블을 커널 가상 메모리**에 위치시킨다.
   - 이를 통해 물리 메모리의 직접적인 부담을 줄일 수 있다.

2. **페이지 테이블의 스왑**
   - 시스템 메모리가 부족한 경우, 페이지 테이블을 **디스크로 스왑(swap)**하여 메모리 공간을 확보한다.
   - 스왑된 페이지 테이블은 필요할 때 다시 메모리에 탑재된다.

### **고려 사항**

1. **효율적인 메모리 관리**
   - 페이지 테이블의 일부를 디스크로 스왑함으로써, 시스템의 **물리 메모리를 효율적으로 활용**할 수 있다.

2. **성능 저하 위험**
   - 디스크 스왑은 메모리 접근보다 훨씬 느리므로, 페이지 테이블이 자주 스왑될 경우 시스템 성능에 영향을 미칠 수 있다.


모든 페이지 테이블을 물리 메모리에 상주시킬 수 없는 경우, 페이지 테이블을 커널 가상 메모리로 이동시키거나, 필요한 경우 디스크로 스왑하여 메모리 공간을 확보할 수 있다. 이는 메모리 관리의 유연성을 높이는 동시에, 성능 저하와 같은 단점도 함께 고려해야 하는 방식이다.