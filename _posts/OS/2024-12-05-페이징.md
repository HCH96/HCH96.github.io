---
title: 페이징
date: 2024-12-05 18:00:00 +09:00
categories: [OS, Virtualization]
tags:
  [operating system, ostep, 페이징]
---

## **페이징(paging)** 
페이징은 가상 주소 공간을 고정 크기의 단위인 **페이지(page)**로 나누어 메모리를 관리하는 방식이다. 각 페이지는 물리 메모리의 **페이지 프레임(page frame)**에 매핑된다.

### **예시**
- 가상 주소 공간의 크기는 64바이트이고, 각 페이지는 16바이트 크기로 4개의 페이지로 나뉜다.

![alt text](/assets/img/OS/페이징/image.png){: style="width: 80%; display: block; margin: 0 auto;" }
_64바이트 주소 공간_

- 물리 메모리의 크기는 128바이트이고, 8개의 페이지 프레임이 존재한다. 가상 주소 공간의 각 페이지는 물리 메모리의 페이지 프레임에 분산 배치된다.

![alt text](/assets/img/OS/페이징/image-1.png){: style="width: 80%; display: block; margin: 0 auto;" }
_128바이트의 물리 메모리_

### **장점**
- 유연성: 프로세스의 주소 공간 사용방식과는 상관없이 효율적으로 주소 공간 개념을 지원할 수 있다. 예를 들어, 힙과 스택이 어느 방향으로 커지는지, 어떻게 사용되는지에 대한 가정을 하지 않아도 된다.
- 단순성: 운영체제가 가상 주소 공간에 필요한 만큼 빈 페이지를 찾아 배치하면 된다.
- 효율성: 유효하지 않은 주소 공간에 메모리를 할당하지 않아 메모리를 절약할 수 있다.

---

## **페이지 테이블**
페이지 테이블은 **가상 주소**를 **물리 주소**로 변환하기 위해 운영체제가 유지하는 자료 구조이다.

![alt text](/assets/img/OS/페이징/image-4.png){: style="width: 80%; display: block; margin: 0 auto;" }
_커널 물리 메모리에 존재하는 페이지 테이블_

### **구조**
페이지 테이블은 선형 페이지 테이블로 구성되며, 배열 형태를 가진다. 가상 페이지 번호(VPN)를 인덱스로 사용하여 물리 프레임 번호(PFN)를 찾는다. 페이지 테이블 항목(PTE)에는 변환 정보와 추가적인 속성이 저장된다.

### **PTE 주요 비트**
- **Valid bit**: 변환이 유효한지 여부를 나타낸다.
- **Protection bit**: 접근 권한을 제어한다.
- **Present bit**: 페이지가 메모리에 있는지, 디스크로 스왑되었는지를 나타낸다.
- **Reference bit**: 페이지가 접근되었는지를 추적한다.
- **Dirty bit**: 페이지가 수정되었는지를 나타낸다.

![alt text](/assets/img/OS/페이징/image-5.png){: style="width: 90%; display: block; margin: 0 auto;" }
_x86 페이지 테이블 항목 (PTE)_

위의 그림은 x86 아키텍처의 페이지 테이블 항목을 나타내며, 여기에는 페이지의 존재 여부(P), 읽기/쓰기 비트(R/W), 사용자 모드 접근 여부(U/S), 캐시 동작 제어 비트(PWT, PCD, PAT, G), 참조 비트(A), 변경 비트(D), 그리고 페이지 프레임 번호(PFN)가 포함된다.

---

## **주소 변환**

프로세스가 생성한 가상 주소의 변환을 위해 가상 주소를 **가상 페이지 번호(virtual page number, VPN)**와 페이지 내의 **오프셋** 2개의 구성요소로 으로 분할한다.

![alt text](/assets/img/OS/페이징/image-2.png){: style="width: 80%; display: block; margin: 0 auto;" }
_가상 페이지 번호_

위의 예시에서 가상 주소 공간의 크기는 64바이트이므로 가상 주소를 표현하기 위해 6비트가 필요하다. 페이지 크기는 16바이트이며, 가상 주소 공간이 64바이트이기 때문에 전체 주소 공간은 4개의 페이지로 나누어진다. 이 4개의 페이지를 표현하기 위해 최상위 2비트는 가상 페이지 번호(VPN)로 사용하고, 나머지 비트는 페이지 내 오프셋을 나타낸다.

예를 들어, 가상 주소가 21인 경우 이진 형식으로 변환하면 **010101**이 된다. 이때, 가상 주소 **"21"**은 가상 페이지 **01**의 **5번째(0101번째)**바이트를 가리킨다.

이 가상 페이지 번호를 페이지 테이블에서 인덱스로 사용하면, 가상 페이지 1이 물리 페이지 프레임 번호 7에 저장된다는 것을 알 수 있다. 오프셋은 그대로 유지된다.

![alt text](/assets/img/OS/페이징/image-3.png){: style="width: 80%; display: block; margin: 0 auto;" }
_주소 변환 과정_

---
### **페이징의 단점**
페이징의 단점은 페이지 테이블이 메모리에서 많은 공간을 차지하고, 이로 인해 성능 저하를 유발한다는 것이다. 예를 들어, `movl 21, %eax` 명령어를 실행할 때, 가상 주소(21)를 물리 주소(117)로 변환하기 위해 페이지 테이블을 참조해야 한다. 페이지 테이블 항목(PTE)을 찾는 과정에서 가상 주소에서 VPN을 추출하고, 이를 바탕으로 페이지 테이블에서 물리 프레임 번호(PFN)를 찾는다. 그 후, PFN을 사용하여 물리 주소를 계산하고, 해당 주소에서 데이터를 가져온다.

![alt text](/assets/img/OS/페이징/image-6.png){: style="width: 100%; display: block; margin: 0 auto;" }
_페이징을 사용한 메모리 접근_

이 과정은 페이지 테이블 접근과 물리 메모리 접근이 각각 한 번씩 발생하므로 성능에 영향을 미친다. 페이지 테이블이 커질수록, 추가적인 메모리 참조가 필요해져 시스템 속도가 느려진다.




### 메모리 트레이스
마치기 전에, 간단한 메모리 액세스 예를 통해 페이징을 사용했을 때 발생하는 모든
메모리 접근을 살펴보자. 우리가 관􁝍있는 코드는(파일 array.c의 C 언어로 된) 다음과
같다.
```c
int array[1000];
for (i = 0; i < 1000; i++)
    array[i] = 0;
```

```
1 0x1024 movl $0x0 , ( % edi,%eax,4)
2 0x1028 incl %eax
3 0x102c cmpl $0x03e8,%eax
4 0x1030 jne 0x1024
```

배열의 각 원소를 0으로 설정하는 작업을 반복하는 코드이다. 이때 배열에 접근하는 모든 과정에서 가상 주소를 물리 주소로 변환하는 작업이 필요하다. 이 변환은 페이지 테이블을 통해 이루어지며, 각 메모리 참조에서 페이지 테이블을 한 번 참조한 후 실제 데이터를 가져오는 또 다른 메모리 참조가 발생한다.

이 코드에서 `mov` 명령어는 두 번의 메모리 참조를 발생시킨다.
- 가상 주소에서 물리 주소로 변환하기 위한 페이지 테이블 접근.
- 배열의 실제 데이터에 접근.

![alt text](/assets/img/OS/페이징/image-7.png){: style="width: 90%; display: block; margin: 0 auto;" }