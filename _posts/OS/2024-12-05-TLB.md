---
title: 페이징 - 더 빠른 변환(TLB)
date: 2024-12-05 20:00:00 +09:00
categories: [OS, Virtualization]
tags:
  [operating system, ostep, 페이징, TLB]
---

## **TLB(Translation Lookaside Buffer)**

**TLB**는 가상 주소를 실주소로 빠르게 변환하기 위해 **MMU**에 내장된 하드웨어 캐시로, 자주 참조되는 변환 정보를 저장해 페이지 테이블 조회를 생략하도록 돕는다.

---

### **TLB의 기본 알고리즘**

1. 가상 페이지 번호(virtual page number, VPN) 추출한다.
2. 해당 VPN이 TLB에 존재하는지 검사한다.
3. 만약 존재한다면(TLB Hit) 해당 항목에서 **페이지 프레임 번호(page frame number, PFN)**를 추출하여 사용한다.
4. 만약 존재하지 않는다면(TLB Miss) 페이지 테이블을 참조한다.
5. 페이지 테이블의 해당 항목이 유효하고, 접근 가능하다면 해당 항목을 TLB로 읽어들인다.
6. TLB가 갱신되면 하드웨어는 TLB를 낸 명령어를 재실행한다.

TLB 미스가 발생하면 메모리(페이지 테이블)에 접근해 주소 변환 정보를 읽어들여야 한다. 메모리 접근 연산은 다른 CPU 연산에 비해 매우 시간이 오래 걸리기 때문에 TLB 미스가 발생하는 경우를 최대한 줄여야한다.

### **예제**

- 가상 주소 공간의 크기는 256Byte로 주소를 표현하기 위해 8비트를 사용한다.
- 페이지의 크기는 16Byte로 가상 주소는 4비트의 VPN과 4비트의 오프셋으로 구성된다.
- 가상 주소 공간의 페이지 수는 16개이다.
- 가상 주소 100번지부터 10개의 4바이트 크기의 정수 배열이 존재한다.

![alt text](/assets/img/OS/TLB/image.png){: style="width: 50%; display: block; margin: 0 auto;" }
_작은 주소 공간 내의 배열_

```c
int sum = 0;
for (i = 0; i < 10; i++) {
    sum += a[i];
}
```

- 위와 같은 공간에서 10개의 배열에 대한 합을 구하는 코드를 실행한다.
- 메모리 접근을 단순화하기 위해 변수 i, sum 그리고 명령어를 위한 메모리 접근은 무시한다.


#### **배열에 따른 TLB Hit, Miss**
1. a[0] -> 해당 페이지에 대한 첫 접근이기 때문에 TLB Miss! -> VPN 6을 이용해 물리 주소를 알아내 TLB에 저장한다.
2. a[1],a[2] -> a[0]과 같은 페이지에 존재하기 때문에 TLB Hit! -> TLB의 정보를 이용, 주소를 변환하여 해당 배열 메모리에 접근한다.
3. a[3] -> 해당 페이지에 대한 첫 접근이기 때문에 TLB Miss! -> VPN 6을 이용해 물리 주소를 알아내 TLB에 저장한다.
4. a[4],a[5],a[6] -> a[3]과 같은 페이지에 존재하기 때문에 TLB Hit! -> TLB의 정보를 이용, 주소를 변환하여 해당 배열 메모리에 접근한다.
...

배열 원소를 읽는 TLB 동작을 정리해 보면 Miss, Hit, Hit, Miss, Hit, Hit, Hit, Miss, Hit, Hit이 된다. TLB 히트 비율은 70%가 된다.

#### **TLB와 배열 접근 성능**

- 배열을 처음 접근할 때는 TLB 미스가 발생하지만, 배열의 항목들이 페이지 내에서 인접해 있기 때문에 공간 지역성으로 인해 이후 성능이 개선된다.
- 배열의 첫 번째 항목 접근 시에만 TLB 미스가 발생하며, 동일 페이지 내 다른 항목들은 TLB 히트로 처리된다.
- 페이지 크기가 클수록 TLB 미스가 줄어들어 성능이 향상된다. 일반적인 페이지 크기(4KB)에서는 연속적인 배열 접근 시 한 페이지에 여러 항목을 저장할 수 있어 TLB 사용 효과가 크다.
- 루프가 종료된 후에도 배열을 다시 참조하면, 시간 지역성 덕분에 모든 변환 정보가 이미 TLB에 저장되어 있어 높은 TLB 히트율을 보인다.
- TLB의 성능은 프로그램의 공간 지역성과 시간 지역성 특성에 크게 의존하며, 이러한 특성을 가진 프로그램에서는 TLB의 성능 개선 효과가 더욱 두드러진다.


---

### **TLB 미스 처리**

TLB 미스의 처리 방식에는 하드웨어가 처리하는 방식과 소프트웨어가 처리하는 방식이 존재한다.

#### **하드웨어에서 처리방식**
1. 페이지 테이블에서 원하는 페이지 테이블 엔트리를 찾는다.
2. 필요한 변환 정보를 추출한다.
3. TLB를 갱신한다.
4. TLB 미스가 발생한 명령어를 재실행한다.

인텔 x86 CPU가 하드웨어로 관리되는 TLB의 대표적인 예다. x86 CPU는 멀티 레벨 페이지 테이블(multi-level page table)을 사용한다.

#### **소프트웨어에서 처리방식**
1. TLB 미스 발생 시, 하드웨어는 예외 시그널(exception)을 발생시킨다.
2. 운영체제는 이를 감지하고 커널 모드로 전환하여 TLB 미스를 처리하기 위한 트랩 핸들러를 실행한다.
3. 트랩 핸들러는 다음을 수행한다:
    - 페이지 테이블에서 필요한 변환 정보를 검색한다.
    - 특권 명령어를 사용해 TLB를 갱신한다.
4. 이후 트랩 핸들러는 리턴되고, 하드웨어는 명령어를 다시 실행한다.

#### **TLB 미스 처리 시 고려 사항**

#### 1. 트랩 핸들러의 동작 차이
- **시스템 콜 트랩 핸들러**  
  - 호출 후 리턴 시, 호출한 명령어의 **다음 명령어**를 실행한다.  
  - 일반적인 프로시저 콜의 흐름과 동일하다.

- **TLB 미스 트랩 핸들러**  
  - 리턴 후 **트랩을 발생시킨 명령어**를 다시 실행한다.  
  - 재실행 시 갱신된 TLB를 사용하므로 TLB 히트가 발생한다.  
  - 트랩 발생 시 운영체제는 트랩 원인에 따라 **현재 명령어의 주소** 또는 **다음 명령어의 주소**를 저장해야 한다.

#### 2. TLB 미스 무한 반복 방지
- TLB 미스 핸들러 실행 중 추가적인 TLB 미스를 방지하기 위한 대책:
  - **물리 메모리에 핸들러 저장**  
    - TLB 미스 핸들러를 물리 주소로 접근하도록 하여 주소 변환이 필요 없게 한다.
  - **TLB 일부를 핸들러에 영구 할당**  
    - 핸들러 코드 주소를 TLB에 고정(wired) 저장하여 항상 TLB 히트를 보장한다.

#### 3. 소프트웨어 기반 TLB 관리의 장점
- **유연성**  
  - 운영체제가 하드웨어 변경 없이 페이지 테이블 구조를 자유롭게 수정할 수 있다.
- **단순성**  
  - TLB 미스가 발생했을 때 하드웨어는 예외만 발생시키고, 나머지는 운영체제의 TLB 미스 핸들러가 처리한다.

소프트웨어 기반 TLB 관리는 다양한 환경에서 효율적으로 적용될 수 있다.


---

### **TLB 구성**

#### 1. 일반적인 TLB의 특징
- TLB는 **32, 64, 또는 128개의 엔트리**를 가지며, **완전 연관(fully associative)** 방식으로 설계된다.
- **완전 연관 방식**에서는 변환 정보가 TLB 내 어디에든 저장될 수 있으며, 하드웨어가 TLB 전체를 **병렬적으로 검색**하여 변환 정보를 찾는다.

#### 2. TLB 항목의 구성
- 각 TLB 항목은 다음과 같은 정보를 포함한다:
  - **VPN (가상 페이지 번호):** 가상 주소를 나타냄.
  - **PFN (물리 페이지 번호):** 물리 주소를 나타냄.
  - **기타 비트들:** 추가적인 제어 정보 포함.
    - **유효 비트 (valid bit):** 변환 정보가 유효한지 여부를 나타냄.
    - **보호 비트 (protection bit):** 페이지 접근 권한을 정의.  
      예) 코드 페이지: 읽기/실행, 힙 페이지: 읽기/쓰기.
    - **주소 공간 식별자 (ASID):** 프로세스 간 주소 공간을 구분.
    - **더티 비트 (dirty bit):** 페이지가 수정되었는지 여부를 표시.

#### 3. TLB의 하드웨어 동작
- 하드웨어는 변환 정보를 찾을 때 TLB 내 **모든 항목을 동시에 검색**한다.
- 완전 연관 캐시 설계 덕분에 변환 정보를 빠르게 찾아낼 수 있다.

이와 같은 구조는 TLB가 가상 주소를 물리 주소로 효율적으로 변환하도록 돕는다.

> TLB의 **valid bit**는 TLB에 저장된 변환 정보가 유효한지 여부를 나타내며, 페이지 테이블의 valid bit와는 다르다. 페이지 테이블의 valid bit가 "무효"라면 해당 페이지는 프로세스에 할당되지 않았음을 의미한다. 문맥 전환 시 TLB의 모든 valid bit를 "무효"로 초기화하여 이전 프로세스의 변환 정보 사용을 방지한다.
{: .prompt-tip }

---

### **TLB와 멀티프로세스 환경에서의 문맥 전환**

#### 1. TLB 변환 정보와 프로세스 간 충돌 문제
- TLB에 저장된 변환 정보는 **탑재된 프로세스에서만 유효**하며, 다른 프로세스에서는 의미가 없다.
- **문맥 전환** 시 이전 프로세스의 변환 정보를 새 프로세스가 사용하는 것을 방지해야 한다.
- 예를 들어:
  - 프로세스 P1: 10번째 가상 페이지(VPN)가 물리 프레임(PFN) 100에 매핑.
  - 프로세스 P2: 10번째 가상 페이지가 물리 프레임 170에 매핑.
  - 동일한 VPN(10)에 대해 두 개의 변환 정보가 존재하면 하드웨어는 어떤 프로세스의 정보인지 구분할 수 없다.

![alt text](/assets/img/OS/TLB/image-2.png)
_TLB 변환 정보와 프로세스 간 충돌 문제_

#### 2. 해결 방법
- **TLB 초기화(플러시):**
  - 문맥 전환 시, TLB를 비워 잘못된 변환 정보 사용을 방지.
  - 모든 **유효 비트(valid bit)**를 0으로 설정해 초기화.
  - 단점: 새로운 프로세스 실행 시, 데이터 및 코드 페이지 접근 시 TLB 미스가 발생하여 성능 부담이 증가.

- **주소 공간 식별자(ASID) 사용:**
  - TLB 항목에 **ASID(Address Space Identifier)** 필드를 추가해 프로세스별 변환 정보를 구분.
  - 문맥 전환 시 운영체제가 현재 실행 중인 프로세스의 ASID를 하드웨어에 탑재.
  - 이를 통해 TLB를 초기화하지 않고도 멀티프로세스 환경에서 효율적으로 동작 가능.

![alt text](/assets/img/OS/TLB/image-3.png)
_ASID 필드를 추가한 TLB의 모습_

#### 3. 프로세스 간 페이지 공유
- 동일한 물리 페이지를 두 프로세스가 공유하는 경우:
  - 예) 프로세스 P1은 물리 페이지 101을 VPN 10에 매핑, P2는 VPN 50에 매핑.
  - 이는 **코드 페이지**나 **공유 라이브러리**와 같은 자원을 공유할 때 발생.
  - 공유를 통해 메모리 사용량을 줄이고 성능 효율을 높일 수 있다.

![alt text](/assets/img/OS/TLB/image-4.png)
_프로세스 간 페이지 공유_

---

### **TLB의 캐시 교체 정책**

#### 1. 캐시 교체 정책의 중요성
- TLB에 새로운 항목을 추가할 때, 기존 항목 중 하나를 교체해야 한다.
- 적절한 교체 정책을 통해 TLB 미스를 최소화하고 성능을 향상시킬 수 있다.

#### 2. 주요 교체 정책
- **LRU (Least-Recently-Used):**
  - 가장 오래 사용되지 않은 항목을 교체 대상으로 선정.
  - 메모리 참조의 **지역성(Locality)**을 활용하여, 오래 사용되지 않은 항목은 앞으로도 사용되지 않을 가능성이 높다는 가정에 기반.
  - 단점: 일부 특정 상황에서는 모든 접근이 미스를 유발할 수 있음.
    - 예: TLB가 n개의 항목을 저장할 수 있을 때, n+1개의 페이지를 반복적으로 접근하는 경우.

- **랜덤(Random):**
  - 교체 대상을 무작위로 선택.
  - 장점:
    - 구현이 간단.
    - 특정 상황에서 예외적으로 발생할 수 있는 문제(LRU의 최악 상황 등)를 피할 수 있음.
  - 단점: 일부 잘못된 교체 결정을 내릴 가능성.

#### 3. 정책 선택의 고려 사항
- 프로그램의 메모리 접근 패턴에 따라 최적의 교체 정책이 달라질 수 있음.
- 랜덤 정책은 단순성과 안정성을, LRU는 지역성을 최대한 활용할 수 있는 상황에서 적합하다.
